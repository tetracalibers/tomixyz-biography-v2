---
import WebGPUDemoLayout from "$/layouts/webgpu-demo.astro"
---

<WebGPUDemoLayout title="WebGPUによる三角形">
  <canvas id="canvas" width="640" height="480"></canvas>
</WebGPUDemoLayout>

<script>
  const adapter = await navigator.gpu.requestAdapter()
  if (!adapter) {
    throw new Error("WebGPU cannot be initialized - Adapter not found")
  }

  const device = await adapter.requestDevice()
  device.lost.then(() => {
    throw new Error("WebGPU cannot be initialized - Device has been lost")
  })

  const canvas = document.querySelector("canvas")
  const context = canvas!.getContext("webgpu")
  if (!context) {
    throw new Error("WebGPU cannot be initialized - Canvas does not support WebGPU")
  }

  const format = navigator.gpu.getPreferredCanvasFormat()
  context.configure({ device, format })

  const vertexData = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])

  const vertexBuffer = device.createBuffer({
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
  })
  device.queue.writeBuffer(vertexBuffer, 0, vertexData)

  const shaderModule = device.createShaderModule({
    code: `
struct VertexOut {
  @builtin(position) Position : vec4<f32>,
};

@vertex
fn vs_main(@location(0) position : vec2<f32>) -> VertexOut {
  var out: VertexOut;
  out.Position = vec4<f32>(position, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  return vec4<f32>(1.0, 0.0, 0.0, 1.0);
}
`
  })

  const pipeline = device.createRenderPipeline({
    layout: "auto",
    vertex: {
      module: shaderModule,
      entryPoint: "vs_main",
      buffers: [
        {
          arrayStride: 8,
          attributes: [{ shaderLocation: 0, format: "float32x2", offset: 0 }]
        }
      ]
    },
    fragment: {
      module: shaderModule,
      entryPoint: "fs_main",
      targets: [{ format }]
    },
    primitive: { topology: "triangle-list" }
  })

  const encoder = device.createCommandEncoder()
  const pass = encoder.beginRenderPass({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        loadOp: "clear",
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        storeOp: "store"
      }
    ]
  })

  pass.setPipeline(pipeline)
  pass.setVertexBuffer(0, vertexBuffer)
  pass.draw(3)
  pass.end()

  device.queue.submit([encoder.finish()])
</script>
