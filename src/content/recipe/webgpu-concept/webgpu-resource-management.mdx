---
title: WebGPUのリソース管理
date: "2025-04-10"
description: リソースと状態に着目した、WebGLとWebGPUの比較
series: webgpu-concept
tags:
  - webgpu
  - webgl
---

## 状態の扱いが変わればリソースの扱いも変わる

WebGPUは、WebGLとは大きく異なる設計思想を持ったGPU APIです。
WebGLがいわゆるステートフルなAPIであるのに対し、WebGPUはステートレスな設計になっています。

- ==WebGL==：ステートフル（状態を保持）
- ==WebGPU==：ステートレス（状態を持たない）

このような設計の違いから、WebGLからWebGPUへとパラダイムを切り替える際に、特に大きなギャップとなるのが、リソース管理のアプローチです。

そこで今回は、「状態」と「リソース」に着目して、WebGLとWebGPUの違いを掘り下げていきます。

> [!TIP]
> 「状態」「リソース」「ステートフル」「ステートレス」などは、一般的なプログラミングでも登場する概念ですが、ここではGPU APIの文脈における意味を中心に解説します。

## 状態（ステート）とは何か

プログラムが何かを実行する際には、常にいくつかの「設定」や「前提条件」が存在しています。

- 今使っているテクスチャは何か
- 描画対象のバッファはどれか
- 有効なブレンドモードや深度設定はどうなっているか
- どのシェーダが現在アクティブか
- etc.

こうした情報の集合を、一般に==ステート（状態）==と呼びます。
GPU APIにおいては、「現在の描画環境にどんな設定が使われているのか」がステートです。

また、==ステートフル==や==ステートレス==という言葉は、描画や処理に必要な「設定」がどこに存在し、どう管理されるかを表すものです。詳しくは後ほど、具体例を通してその違いを解説します。

## リソースとは何か

WebGLやWebGPUにおいて、==リソース==とは、GPUに渡すためのデータや構成要素を指します。

- ==バッファ==：頂点情報や数値データを格納するためのメモリ領域
- ==テクスチャ==：画像データなどをGPUに渡すための形式
- etc.

これらのリソースは、描画や演算処理の素材として使われます。

## WebGLは状態依存、WebGPUは状態を閉じ込める

WebGLでは、描画やリソース操作を行う際に、常に「今どんな状態なのか」を意識する必要があります。たとえば、どのテクスチャが現在使われているのか、どのバッファがバインドされているのか、どのシェーダープログラムが有効なのかといった情報は、すべて“グローバルな状態”として扱われています。こうした状態は一度設定するとそのまま残り、明示的に変更しない限り、次の描画にも影響を与えます。

WebGLでは、こうしたリソースを作成したり利用したりする際に、==バインド==と呼ばれる手続きを毎回行う必要があります。しかも、このバインド操作も状態に依存しているため、順序を間違えたり、必要なバインドを忘れたりすると、意図した結果が得られないことがあります。

一方でWebGPUには、そうしたグローバルな状態がほとんど存在しません。代わりに「パイプライン」や「レンダーパス」と呼ばれるオブジェクトに、必要な状態をすべてまとめて閉じ込める設計になっています。これにより、どの状態で描画が行われるのかが明確になり、予測しやすく、バグの原因になりにくくなっています。

WebGPUでは、リソースの作成も使用もすべて明示的です。たとえばバッファを作成するときには、どのくらいのサイズで、どんな用途で使うか（描画用なのか、読み書き用なのか）を明確に指定します。テクスチャを作成する際も、使用目的やフォーマットを細かく定義します。こうした仕様によって、GPUが内部で最適な配置や処理を行いやすくなり、パフォーマンスも向上しやすくなっています。

## ステートフル（Stateful）とは？

「ステートフル」とは、**APIの動作が現在の状態に強く依存している**ことを意味します。

たとえばWebGLでは、次のような描画手順を踏むとします：

```javascript
gl.bindTexture(gl.TEXTURE_2D, myTexture);
gl.useProgram(myShader);
gl.drawArrays(gl.TRIANGLES, 0, 6);
```

このとき `gl.drawArrays()` が何を描画するかは、**その直前にバインドされたテクスチャやシェーダー、バッファの状態**によって決まります。これが**ステートフルなAPI**の典型です。

つまり、APIの呼び出しの意味や結果は、「それ以前にどんな状態がセットされているか」によって変わります。状態を変更する関数（たとえば `bindTexture()` や `enable()`）は、**グローバルに影響し、後続の描画すべてに効いてくる**という特性があります。

これは柔軟さのある設計ですが、一方で「今どんな状態なのか？」を常に意識してコードを書く必要があり、**バグの原因になりやすく、抽象化が難しい**という欠点もあります。

## ステートレス（Stateless）とは？

一方の「ステートレス」とは、**処理を行うたびに必要な設定がすべて明示されている**ことを意味します。WebGPUはこのステートレス設計を採用しています。

たとえばWebGPUでは、描画を行う前に「レンダーパイプライン」や「バインドグループ」などのオブジェクトを作成し、その中にシェーダーやテクスチャ、バッファなど必要な情報をすべて詰め込みます。そして描画時には、それを**明示的に渡して実行**します。

```javascript
commandEncoder.setPipeline(renderPipeline);
commandEncoder.setBindGroup(0, bindGroup);
commandEncoder.draw(6, 1, 0, 0);
```

このコードでは、「どんなシェーダーで」「どのリソースを使って」「何を描画するか」がすべてその場で指定されており、**それ以前に何をしたかには依存していません**。

これが「ステートレス」の基本的な発想です。状態を外に持たず、その都度必要な情報を提供することで、**処理の見通しがよくなり、非同期化や最適化がしやすくなる**という利点があります。

## ステートフル vs ステートレス：例え話

わかりやすく言えば、

- ステートフルなAPIは「コンロのつまみをひねって火力を調整しながら料理する」スタイル  
- ステートレスなAPIは「レシピと材料をすべて揃えて、一括で調理ロボットに渡す」スタイル

前者は融通がききますが、いちいち状態を気にしなければならず、ミスもしやすい。後者は準備が少し面倒ですが、一度整えば正確かつ効率的に処理してくれます。

## まとめ

- **ステート**：現在のGPU設定や動作条件のこと
- **ステートフル**：過去の設定に依存するAPI設計（WebGLなど）
- **ステートレス**：必要な設定を毎回明示する設計（WebGPUなど）

WebGPUは、「状態を明示的に記述する」ことで、**予測可能でバグの少ない描画処理**を目指すステートレスなAPIです。初めは少し冗長に感じるかもしれませんが、その構造化された設計は、**中・長期的には信頼性と保守性を大きく高めてくれます**。

---

## パイプラインという考え方

WebGPUの中核をなす概念のひとつが「パイプライン」です。これは、描画を行うための設定やリソースの組み合わせをひとまとめにしたものです。たとえば、どの頂点シェーダーやフラグメントシェーダーを使うか、どんなバッファをどのように扱うか、ブレンディングや深度処理の方法など、描画に必要なすべての設定を事前にまとめておきます。

このパイプラインは一度作ると変更できず、必要があれば新しく作り直します。この「イミュータブル（不変）」な設計は、GPU側の最適化を助けるだけでなく、開発者にとっても状態の変化を見通しやすくする効果があります。

## コマンドの記録と実行

WebGLでは、関数を呼び出すとその場で即座にGPUへ命令が送られます。これは「即時実行型」の設計と呼ばれ、単純な構造ですが、複雑な処理になるとパフォーマンスのボトルネックになることもあります。

WebGPUは「遅延実行型」と呼ばれ、GPUへの命令はすぐには送られません。代わりに「コマンドエンコーダ」というオブジェクトに一連の命令を記録し、それをまとめて「コマンドバッファ」にしてGPUに送ります。これにより、命令の順序や内容を吟味しながら準備でき、結果的に効率のよい処理が可能になります。

## メモリ管理の違い

WebGLでは、バッファやテクスチャを明示的に破棄するAPIも存在しますが、実際にはJavaScriptのガーベジコレクションに任せるケースが多く、ライフサイクルの制御はあいまいです。そのため、大きなアプリケーションではメモリの無駄遣いやリークが起きやすくなります。

一方WebGPUでは、リソースは基本的に開発者が明示的に作成し、必要がなくなれば自分で破棄します。たとえばバッファには`destroy()`というメソッドが用意されており、使い終わったら自分で破棄するのが基本です。このようにして、メモリの管理をより厳密に行うことができます。

## WebGPUは難しい？ それとも親切？

WebGPUは、プログラマが設定しなければならない項目が多く、その明示的な設計も最初は手間に思えるでしょう。しかしその一方で、**状態がはっきりしている**ということは、**バグの原因が見えやすく、動作が予測しやすい**ということでもあります。

また、事前に構成を固めるという仕組みは、後から見返したときにも「何がどのように描画されているか」を把握しやすく、長期的には開発者の負担を軽減します。

## おわりに

WebGPUでは、リソースの取り扱いや描画処理をより明示的に、より構造的に行えるようになったことで、**高い自由度とパフォーマンスを両立**できるようになりました。

---

## ステートフル vs ステートレス

### WebGL：状態に依存したグローバル設計

WebGLは**グローバルな状態マシン**として設計されており、関数を呼び出すとその状態がアプリケーション全体に影響します。

例：

```javascript
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.enable(gl.BLEND);
gl.useProgram(program);
```

これらは「現在の状態を上書きする操作」であり、**明示的に戻さない限り持続します**。このため、描画時に「今どの状態だったか？」という把握が常に必要で、**抽象化やライブラリ化が難しくなる要因**となります。

> 💡参考：状態の可視化には [WebGL State Diagram](https://webglfundamentals.org/webgl/lessons/resources/webgl-state-diagram.html) が非常に役立ちます。

### WebGPU：明示的なオブジェクト志向設計

WebGPUでは、状態をグローバルに持たず、**事前に定義されたオブジェクト（パイプラインやレンダーパス）に状態を閉じ込める**形になっています。

これにより、

- どの状態を使うか明示的に定義できる
- 状態の追跡が不要でバグが減る
- 記録と実行を分離でき、非同期化や最適化がしやすい

といったメリットがあります。

## WebGLとWebGPUの根本的な違い

| 特徴           | WebGL                              | WebGPU                               |
|----------------|-------------------------------------|---------------------------------------|
| ベースAPI      | OpenGL ES 2/3                       | Vulkan / Metal / DirectX 12           |
| 設計思想       | 暗黙的、即時実行型                  | 明示的、遅延実行型（非同期）         |
| GPGPU          | 制限あり（工夫が必要）              | コンピュートシェーダーで直接可能     |
| リソース管理   | 自動（ブラックボックスに近い）      | 明示的（開発者が制御）                |
| パフォーマンス | 比較的低い                          | 高パフォーマンスが狙える             |

## バッファ・テクスチャの生成と管理

### リソースの作成方法

| 観点         | WebGL                                      | WebGPU                                                  |
|--------------|---------------------------------------------|----------------------------------------------------------|
| バッファ作成 | `gl.createBuffer()`                        | `device.createBuffer()`（サイズ・用途を定義）            |
| 書き込み     | `gl.bufferData()`（暗黙のバインド前提）     | `mappedAtCreation: true` でマッピングして書き込む        |
| テクスチャ   | 曖昧なフォーマット                         | `GPUTextureDescriptor`で用途・フォーマットを厳密に定義   |
| 破棄         | `gl.deleteBuffer()`（GC頼りがち）          | `buffer.destroy()` による明示的な破棄が可能             |

> 🎯 WebGPUでは**すべてのリソースのライフサイクルが明示的**。パフォーマンスチューニングやメモリ制御がしやすくなります。

## 状態管理とコマンドの記録

### WebGLの状態管理：都度バインドが必要

```javascript
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(...);
gl.drawArrays(...);
```

- 状態の変化が暗黙的
- 使用前に常にバインド
- 順序がバグを生みやすい

### WebGPU：パイプラインによる明示的な組み立て

```javascript
const vertexBuffer = device.createBuffer({ ... });
const pipeline = device.createRenderPipeline({ ... });
const encoder = device.createCommandEncoder();
```

- リソースと状態を一括で構成
- コマンドを記録して後でまとめて送信
- 状態の追跡不要でわかりやすい

## パイプラインと描画フローの違い

| 観点             | WebGL                                          | WebGPU                                               |
|------------------|------------------------------------------------|------------------------------------------------------|
| パイプライン定義 | 状態とシェーダーをその場で組み合わせ         | `GPURenderPipeline`で事前に固定構成を作成           |
| 切り替え         | `gl.useProgram()`や`gl.enable()`等で都度変更 | `setPipeline()` で切り替え。コマンド内で完結         |
| 拡張性           | ライブラリ化・再利用が難しい                  | 状態の合成がしやすく、マルチパス描画も柔軟           |

## メモリ管理とパフォーマンス

- **WebGL**：GCまかせの曖昧なライフサイクル管理  
- **WebGPU**：`destroy()` による明示的制御。**GPUメモリの無駄を防ぎやすい**

また、WebGPUは**非同期処理・コマンドバッファ**を通じて、CPU-GPU間の通信最適化が可能です。

## まとめ：リソース管理の比較表

| 項目             | WebGL                     | WebGPU                                     |
|------------------|----------------------------|---------------------------------------------|
| 管理スタイル     | 暗黙的、即時実行型        | 明示的、記録型（遅延実行）                 |
| 状態の扱い       | グローバル状態マシン       | パイプラインで構成・分離                    |
| リソース生成     | 即時生成、暗黙の使用       | 厳密な定義と用途指定が必要                 |
| メモリ管理       | 自動、破棄は曖昧           | `destroy()` などで明示的に制御             |
| パフォーマンス   | 状態依存で予測しづらい     | 制御性が高く、最適化しやすい               |
| 学習コスト       | 低め（簡単だが曖昧）        | 高め（構造的で高自由度）                   |

## おわりに

WebGPUの**明確な構造と予測可能な設計**は、最初はとっつきにくく見えるかもしれませんが、やがて開発効率や品質の向上につながるはずです。

---

WebGLとWebGPUの最大の違いは、**WebGLはステートフル（状態を保持する）API**で、**WebGPUはステートレス（状態を持たない）API**だという点です。

どういうことかというと、WebGLでは「現在どのテクスチャがバインドされているか」「どのバッファが使われているか」「どのシェーダープログラムが使われているか」「ブレンディングやデプス、ステンシルの設定はどうなっているか」といった、**たくさんの“グローバル状態”**が存在しています。  
たとえば `gl.bindBuffer`、`gl.enable`、`gl.blendFunc` といった関数を呼んで状態を設定すると、それは**明示的に変更しない限りずっとグローバルに残り続けます**。

一方、WebGPUではそういったグローバルな状態はほとんど存在せず、代わりに**「パイプライン（Pipeline）」や「レンダーパス（Render Pass）」という概念**があります。  
これらは、WebGLでいうグローバル状態の大部分――テクスチャや属性、バッファ、その他いろいろな設定――を**まとめて持つ仕組み**です。

しかも、WebGPUでは**パイプラインを一度作ったら変更できません（イミュータブル）**。別の設定にしたいなら、新しくパイプラインを作り直す必要があります。  
レンダーパスには多少状態がありますが、それも**そのレンダーパスの中だけのローカルな状態**です。

つまり、WebGLのように「あれ？今どの状態だったっけ？」と悩むことが減って、**明確で予測しやすい設計**になっているのがWebGPUの大きな特徴です。

## WebGLとWebGPUにおけるリソース管理の違い

WebGLでは、リソース（バッファ、テクスチャ、フレームバッファなど）の生成や使用において、多くの処理が**暗黙的かつグローバルな状態に依存**しています。

WebGLのAPI呼び出しによって、どのように内部のグローバルな状態が変化していくかは、次のサイトによる可視化がとても参考になります。

- [WebGL State diagram](https://webglfundamentals.org/webgl/lessons/resources/webgl-state-diagram.html)

OpenGLのAPIはさらに昔から存在していて、今の基準で見ると、あまり良いAPIとは言えません。
その設計は「内部のグローバルな状態オブジェクト（ステート）」を中心に作られています。

この設計は、一つ一つの呼び出しでGPUとの間にやり取りするデータ量を最小限に抑える、という観点では理にかなっています。
ですがその一方で、プログラマーが状態を常に把握しておく必要があるため、理解や管理が難しく、精神的な負担が大きくなってしまいます。

内部の状態オブジェクトというのは、基本的にはポインタの集合体です。APIの呼び出しは、その状態オブジェクトが指している各オブジェクトに影響を与えることもあれば、状態オブジェクト自体を変えてしまうこともあります。

その結果として、APIの呼び出し順がとても重要になります。そして、この仕組みが抽象化やライブラリの構築を難しくしていると私はずっと感じていました。
これから呼び出すAPIに干渉しそうなポインタや状態を丁寧に“消毒”（リセット）しないといけないし、使い終わったら元の状態に戻しておかないと、抽象化がうまく合成できなくなるんです。

<div>

| 特徴           | WebGL                              | WebGPU                               |
| -------------- | ---------------------------------- | ------------------------------------ |
| ベースAPI      | OpenGL ES 2/3                      | Vulkan / Metal / DX12                |
| 設計思想       | 暗黙的、即時実行型                 | 明示的、非同期型                     |
| GPGPU          | 制限あり（シェーダーの工夫が必要） | コンピュートシェーダーで直接実装可能 |
| リソース管理   | 自動（ただしブラックボックス）     | 明示的（開発者が制御）               |
| パフォーマンス | 比較的低い                         | 高パフォーマンスが可能               |

</div>

WebGPUは、低レベルAPIであるVulkanなどと同様に、リソース（バッファ、テクスチャ、パイプラインなど）を明示的に管理する設計になっています。
これにより、

- 不要な暗黙的処理が減る
- パフォーマンスチューニングがしやすい
- メモリ使用の予測がしやすい

といった利点があります。

以下は「**リソース管理に着目したWebGLとWebGPUの違い**」をまとめた内容です。WebGPUの登場によって**明示的な制御が可能になった**点を中心に、わかりやすく対比しています。

### 概要

一方、WebGPUはVulkanなどのモダンAPIをベースにしており、**すべてのリソースを明示的に定義・管理**する設計になっています。

### バッファ・テクスチャの作成と管理

| 観点 | WebGL | WebGPU |
|------|-------|--------|
| リソース生成 | `gl.createBuffer()`などで即座に生成 | `device.createBuffer()`で明示的に定義（サイズ・用途・マッピング指定） |
| データの書き込み | `gl.bufferData()`などで即時送信（暗黙的バインド） | `mappedAtCreation: true`などの指定で明示的にマッピング・書き込み |
| テクスチャの仕様 | フォーマットや用途が緩く、GPUに最適化されにくい | `GPUTextureDescriptor`で用途（renderable, storage等）を厳密に指定 |
| ライフサイクル管理 | 多くはGC任せ（`deleteBuffer()`等はあるが曖昧） | オブジェクトの明示的破棄（`destroy()`）が可能で、管理しやすい |

### 状態の管理と依存

WebGLは「状態マシン型」のAPIであり、**グローバルな状態に依存**します。たとえば、バッファやシェーダーを使うには都度バインドする必要があり、**何が現在有効なのか**を常に意識しなければなりません。

```javascript
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(...);
gl.drawArrays(...);
```

一方、WebGPUは「パイプライン型」のAPIです。あらかじめ使うリソースや設定を**すべてオブジェクトとして組み立てておき、コマンドバッファに記録**してからまとめて実行します。

```javascript
const vertexBuffer = device.createBuffer({ ... });
const pipeline = device.createRenderPipeline({ ... });
const commandEncoder = device.createCommandEncoder();
```

これにより、**状態の変化を明示的に定義し、不要なオーバーヘッドを削減**できます。

### レンダリングパイプラインの構築

| 観点 | WebGL | WebGPU |
|------|-------|--------|
| パイプライン定義 | 毎回シェーダーや状態を組み合わせてセットアップ | `GPURenderPipeline`で固定構成を事前に定義 |
| パイプライン切り替え | `gl.useProgram()` や `enable`/`disable` 状態切り替えが頻繁 | `commandEncoder.setPipeline()` で明示的に切り替え |

この構造の違いにより、WebGPUは**描画や演算のオーバーヘッドが少なく、マルチパス描画や最適化が行いやすい**設計になっています。

### メモリ管理とパフォーマンス

- **WebGL**：ブラウザ任せのメモリ管理が中心で、パフォーマンスの予測が難しい  
- **WebGPU**：明示的な`destroy()`や用途指定により、**不要なGPUメモリの浪費を防ぎやすい**

## まとめ

| 比較項目 | WebGL | WebGPU |
|----------|--------|--------|
| 管理スタイル | 暗黙的・即時型 | 明示的・遅延型（記録・実行分離） |
| リソースの種類・用途指定 | ゆるい（動的で柔軟だが不明確） | 厳密（パフォーマンス最適化しやすい） |
| 状態管理 | グローバル状態マシン | オブジェクト志向で状態固定 |
| メモリ管理 | 自動・曖昧 | 明示的に制御可能 |
| 開発者体験 | 学習コスト低め、管理しづらい | 学習コスト高め、制御しやすい |

WebGPUは一見複雑に見えますが、**高い自由度・制御性・パフォーマンス**を提供します。

WebGLとWebGPUの違いをより詳しく知りたい場合は、次のサイトがとても参考になります。

- [WebGPU from WebGL](https://webgpufundamentals.org/webgpu/lessons/webgpu-from-webgl.html)
