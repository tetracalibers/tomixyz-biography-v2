---
title: 頂点バッファとバインディング
date: "2025-04-22"
description: CPUからGPUへデータを渡す基本の仕組み
series: webgpu-concept
references:
  - title: あらためて理解するArrayBuffer - JavaScriptでバイナリデータを扱う方法
    url: https://ics.media/entry/250408/
  - title: WebGPU Vertex Buffers
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html
  - title: WebGPU Buffer Uploads - Best practices
    url: https://toji.dev/webgpu-best-practices/buffer-uploads
  - title: WebGPU Copying Data
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html
  - title: WebGPU Bind Group Layouts
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html
tags:
  - webgpu
  - wgsl
draft: true
---

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGPUTriangleVertexBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle-vertex-buffer.png"

> [!note]
> ここで学ぶこと
>
> - バッファとは何か
> - バッファへデータを書き込む方法の種類
> - バッファのバインディング
> - パイプラインレイアウト（`auto`ではない書き方）

:SeriesPrevLink[前回]{series="webgpu-concept" current="webgpu-vertex-buffer"}は、WebGPUを使って三角形を描画する処理を完成させました。

ところで、三角形の頂点の座標は頂点シェーダ内で配列として定義していましたが、通常はこのようなことはしません。
なぜなら、頂点のデータをシェーダ内で定義してしまうと、そのシェーダはその図形専用のシェーダになってしまうからです。

シェーダは、コンパイルしてパイプラインに組み込むことで、初めて利用できるようになります。
WebGPUのパイプライン作成はそれなりに重い処理であり、図形ごとにシェーダとパイプラインを用意して切り替えながら描画するのは非効率です。

そこで、GPUにデータを渡すための仕組みとして、==バッファ==を導入します。

## WebGPUとメモリ

## バッファとは何か

## バッファにデータを書き込む方法

---

## [DRAFT]

頂点の座標や色など、表示する3Dモデルを表す情報は、普通はシェーダとは別にデータとして読み込んでシェーダに与えます。

さて、重要なことですがシェーダは普通のプログラムと違い、CPU上ではなくGPU上で動くプログラムです。そのため、普通のメモリ上にある変数の値などは基本的に読み込めません。

シェーダにデータを渡すためには、データをGPUからアクセスできるメモリ(いわゆるVRAMなど)に置いておく必要があります。

バッファとは、デバイスメモリ上のデータ列を表すオブジェクトです。デバイスメモリ上のデータを管理し、シェーダに受け渡したりするためには必要不可欠の存在となります。

またシェーダにデータを読み込ませる際、データだけ送ってハイ終わりという訳にはいきません。シェーダがデータをきちんと解釈できるようにするには、目的となるデータの読み込み方をシェーダに教える必要があります。このために用意する「説明書き」のようなものとして「デスクリプション」「デスクリプタセット」といったオブジェクトが存在します。パイプラインにこれらの情報を付け加えることで、初めてシェーダからデータが読めるようになります。

---

## バッファとは何か？

WebGPUにおいてバッファとは、GPUに送るデータを格納するための**メモリ領域**のことです。いわば「データの箱」のような存在で、描画や計算を行うために必要な情報――たとえば頂点の位置、色、法線ベクトル、行列、あるいは計算用の一時データなど――を保存しておく役割を担っています。

バッファの中身はただのバイナリデータです。GPUがその意味を理解するためには、**どんな形式で格納されているのか**を指定したり、**どんな目的で使うか**を事前に教えておく必要があります。

## なぜ明示的な管理が必要なのか？

WebGLでは、バッファを作るときや使うときにあまり多くの情報を指定する必要はありませんでした。`gl.createBuffer()`で作り、`gl.bufferData()`で書き込むだけです。ただしその裏では、多くの状態や挙動が暗黙的に処理されており、「なぜこの描画が失敗したのか」がわかりづらいこともよくありました。

WebGPUでは逆に、**バッファを作成する時点で細かい指定が必要**になります。その分、開発者が意図をはっきり伝えることができ、GPU側でも最適なリソースの準備がしやすくなります。これはパフォーマンスやメモリ効率の面でも重要なポイントです。

## バッファの作成と用途指定

WebGPUでバッファを作るには、`device.createBuffer()` という関数を使います。このとき、どのような使い方をするかを `usage` というフラグで明示します。たとえば：

- **`VERTEX`**：頂点データとして使う
- **`INDEX`**：インデックスバッファとして使う（描画順を指定するのに便利）
- **`UNIFORM`**：シェーダーに定数的な情報を渡す（たとえば変換行列など）
- **`STORAGE`**：読み書き可能な計算用データ（GPGPU用途など）
- **`COPY_SRC` / `COPY_DST`**：他のバッファやテクスチャとの間でコピーするために使う

このように、**どう使うかを最初から明示する**のがWebGPUの基本スタイルです。

## バッファにデータを渡す方法

WebGPUでは、バッファにデータを渡す方法も明示的です。よく使われるのが、`mappedAtCreation: true` を指定して作成時にマッピングし、JavaScript側からバッファのメモリに直接書き込む方法です。

```javascript
const buffer = device.createBuffer({
  size: 256,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})

const arrayBuffer = buffer.getMappedRange()
new Float32Array(arrayBuffer).set([1.0, 0.0, 0.0, 1.0])
buffer.unmap()
```

ここで `getMappedRange()` によって得られるのは、生のメモリ領域です。そこに `Float32Array` などを使ってデータを書き込み、`unmap()` を呼ぶことで、GPU側で利用可能な状態になります。

なお、バッファを使い回して内容だけ書き換えるような場合には、非マップ方式で `queue.writeBuffer()` を使う方法もあります。

## WebGPUにおけるバッファの型と設計

バッファはGPU上に配置されるため、その内容はGPUにとってアクセスしやすい形式でなければなりません。そのため、**配列の並び順（レイアウト）や型のサイズ（たとえば32bit floatや16bit int）**を意識した設計が求められます。

さらに、シェーダー側でどう参照するかにも影響します。たとえば、頂点バッファを使う場合は、頂点ごとにどんな属性（位置・色・UVなど）が並んでいるかを、`vertexState` の中で定義する必要があります。

## バッファの破棄とメモリ管理

WebGPUの設計では、リソースは**自動で破棄されることを前提としません**。使い終わったバッファは明示的に `buffer.destroy()` を呼んで破棄するのが望ましいです。これにより、不要になったGPUメモリを確実に解放でき、メモリリークのリスクを減らせます。

## バッファ設計のポイント

- 用途を明確に（`usage` の指定）
- 型とレイアウトを意識する（シェーダーと合わせる）
- 書き込み方を選ぶ（マッピング vs `writeBuffer`）
- 必要に応じて `destroy()` で破棄

このような「ちょっと面倒なルール」はありますが、裏を返せば、すべてのデータの流れを自分の手で制御できるということでもあります。これは、複雑な処理や高パフォーマンスな描画を行いたい場合にとても大きなメリットになります。

## おわりに

WebGPUにおけるバッファは、単なるデータの入れ物ではなく、**GPUとのやり取りを効率よく、安全に、正確に行うための重要な構成要素**です。用途に応じた設計と明確な制御を前提とするこのAPIは、学び始めは少し難しく感じるかもしれませんが、その分だけ「自分が意図した通りに動く」手応えを得られる仕組みになっています。

---

## バッファってなに？

WebGPUにおける「バッファ（Buffer）」は、簡単に言えば**GPUに渡すためのデータを入れておく箱のようなもの**です。もう少し正確に言うと、**GPUが使うためのメモリ領域**を意味します。

この箱の中には、たとえば次のような情報が入ります：

- 頂点の位置（X, Y, Z）
- 色（R, G, B, A）
- テクスチャの座標
- 行列やパラメータなどの設定値
- 計算結果や一時的な値（GPGPU用途）

これらはすべて、**GPUに送りたい「数字のかたまり」**です。そしてその数字を、WebGPUでは「バッファ」という形式でGPUに渡すのです。

## なぜバッファが必要なの？

GPUはCPUとは別の計算装置で、主に描画や並列計算の処理を担当しています。そのため、何かをGPUで処理したいときは、**データをGPUがアクセスできるメモリ空間に移してあげる必要**があります。

バッファはその“受け渡し場所”です。  
たとえば、「この三角形を描いて」と指示するときは、「この頂点の位置に描いてね」という情報をバッファに入れて、それをGPUに送ります。

## WebGPUではどうやってバッファを作るの？

WebGPUでバッファを作るときは、まずどんな目的で使うのかをはっきりさせます。WebGPUは「バッファを作るなら、その用途を最初に宣言してね」と要求してくるのです。

たとえば：

- 描画に使いたい → 頂点バッファ
- シェーダーに定数を渡したい → ユニフォームバッファ
- データを読み書きしたい → ストレージバッファ

というように、それぞれ目的に応じて「このバッファは何に使うか」を指定します。これによって、WebGPUは**無駄なく効率的にメモリを準備**することができるのです。

## バッファの中身ってどんな形？

バッファの中身は、**ただの連続したバイナリデータ**です。たとえば、`[0.0, 1.0, 0.0, 1.0]` のような浮動小数点数（`Float32`）がずらっと並んでいたり、`[1, 2, 3, 4]` のような整数列だったりします。

でもGPUはそれを「色」や「座標」として直接理解してくれるわけではないので、**「このバッファのこの場所には、何のデータが入っているのか」を一緒に伝える必要**があります。

これが「レイアウト（layout）」です。たとえば「1つの頂点には、位置が3つ（X, Y, Z）、色が4つ（R, G, B, A）あります」というような情報を、プログラム側で教えてあげることで、GPUはバッファの中身を正しく解釈できます。

## バッファとシェーダーはどうつながる？

バッファに入れたデータは、最終的に**シェーダー（GPU上で実行されるプログラム）**によって使われます。

たとえば、バッファに入っている頂点の位置を、頂点シェーダーが読み取って、「この位置に点を描いて」と判断します。また、ユニフォームバッファに入っている変換行列（カメラの視点やズームなど）を使って、図形を回転させたりスケーリングしたりします。

WebGPUでは、どのバッファがどのシェーダー変数に対応するのかを、**バインドグループ**という仕組みで明示的につなげます。これにより、「データの出どころ」と「使い先」が明確に整理されるのです。

## バッファの片付けも自分でやる

WebGPUは高機能な分、「便利な自動処理」はあまり用意されていません。たとえば、バッファを作って使ったあと、「もう使わないよ」と思ったら、**自分で明示的に `destroy()` して片付ける**のが基本です。これによって、無駄なメモリ消費を防ぎ、パフォーマンスを保つことができます。

## おわりに：バッファはGPUとの橋渡し

バッファは、GPUにデータを渡すための**基本中の基本**です。何かを描画するにしても、何かを計算するにしても、そのスタート地点はバッファになります。  
WebGPUでは、「どういうデータを、どんな用途で、どんな形式で使うか」を**はっきりと定義すること**が求められますが、その分だけ**パフォーマンスも精度も上がる**という設計になっています。

---

「バインド（bind）」という言葉は、**WebGLやWebGPUのプログラミングにおいてとてもよく使われる概念**ですが、最初は少し分かりづらいかもしれません。ここでは、**バインドとは何か、なぜ必要なのか、どんなふうに行われるのか**を、わかりやすく説明します。

## バインドとは「つなぐこと」

一言で言えば、**バインド（bind）とは「つなぐ」こと**です。  
もう少し具体的に言うと、

> **あるリソース（バッファやテクスチャなど）を、GPUが使えるように、決められた場所に“ひもづける”操作**

のことを指します。

GPUは、何かを描画したり計算したりするために、たくさんのデータや設定（シェーダー、バッファ、テクスチャなど）を必要とします。でも、いきなり「この変数にデータが入ってるよ」と言われても、それがどこにあるのか分かりません。

そこで、「このデータはここにあるよ」「この設定はこの場所で使うよ」と**あらかじめ“バインド”しておく**ことで、GPUが迷わず正しいリソースにアクセスできるようになるのです。

## WebGLにおけるバインド：グローバルな設定

WebGLでは、次のようなコードをよく見かけます：

```javascript
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(...);
gl.drawArrays(gl.TRIANGLES, 0, 3);
```

この `gl.bindBuffer()` が、まさにバインド操作です。これは「この頂点バッファを、今使うバッファとして設定するよ」という意味です。

WebGLでは、GPUに渡すバッファやテクスチャを **「現在使われているもの（current）」として選択（バインド）しないと、使ってもらえない**という仕組みになっています。いわば「使う道具をテーブルの上に出しておく」ような操作です。

ただし、この方式では**最後にバインドされたものが常に有効になる**というルールのため、描画処理の順番や状態の変更がバグの原因になりやすいという問題もあります。

## WebGPUにおけるバインド：明示的な接続

WebGPUでもバインドという概念は存在しますが、少し違った使われ方をします。WebGPUでは、シェーダーに渡すリソースを「**バインドグループ（bind group）**」という単位でまとめておき、それを**パイプラインに接続する形**で使います。

```javascript
const bindGroup = device.createBindGroup({
  layout: bindGroupLayout,
  entries: [
    {
      binding: 0,
      resource: { buffer: uniformBuffer }
    }
  ]
})

commandEncoder.setBindGroup(0, bindGroup)
```

ここでの `setBindGroup()` がバインド操作にあたります。  
これは、「このバインドグループに含まれるバッファやテクスチャを、シェーダーのバインディングポイントに接続する」という意味になります。

WebGPUでは、**どのリソースがどこに接続されるかが常に明示されている**ので、WebGLよりも安全で予測可能な設計になっています。

## 例えるなら…

バインドの概念は、**コンセントと家電製品の関係**に似ています。

- 家電製品（バッファやテクスチャ）は、電源に繋がなければ使えません。
- そのまま置いてあるだけでは動かず、「ここに繋ぐよ！」とコンセント（バインドポイント）に差す必要があります。
- どの家電をどのコンセントに繋いだかをちゃんと把握していないと、スイッチを入れても動かないかもしれません。

WebGLでは「どのコンセントに何を挿したか」がグローバル状態で管理されていて、上書きされやすい。WebGPUでは、あらかじめ「このセットはこの順番で挿すよ」と組み立ててから、まとめて使うイメージです。

## まとめ

- バインドとは、**リソースをGPUの決まった場所に接続すること**。
- WebGLでは、関数呼び出しの前に状態を都度バインドする必要がある（ステートフル）。
- WebGPUでは、**バインドグループを通じて明示的かつ構造的に接続**する（ステートレス）。
- 正しくバインドされていなければ、GPUはリソースを使うことができない。

---

## 実装：頂点バッファを使った三角形の描画

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2,12}
struct VertexInput {
  @location(0) position: vec2f
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  out.Position = vec4f(in.position, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```js title="JavaScriptによるWebGPUのコード" showLineNumbers {10-17,26-37,63}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas!.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()

const shaderModule = device.createShaderModule({ code: shaderCode })

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main",
    buffers: [
      {
        arrayStride: vertices.BYTES_PER_ELEMENT * 2,
        attributes: [
          {
            shaderLocation: 0,
            offset: 0,
            format: "float32x2"
          }
        ]
      }
    ]
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [
      {
        format: canvasFormat
      }
    ]
  }
})

const commandEncoder = device.createCommandEncoder()

const renderPass = commandEncoder.beginRenderPass({
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.32, g: 0.34, b: 0.36, a: 1 },
      storeOp: "store"
    }
  ]
})
renderPass.setPipeline(renderPipeline)
renderPass.setVertexBuffer(0, vertexBuffer)
renderPass.draw(3)
renderPass.end()

device.queue.submit([commandEncoder.finish()])
```

実行結果は次のようになります。

<DemoLinkWithResult
  url="https://tomixyz-sketchbook.pages.dev/basics/webgpu-triangle-vertex-buffer/"
  result={img_WebGPUTriangleVertexBuffer}
  title="頂点バッファを使って三角形を描画するデモ"
/>
