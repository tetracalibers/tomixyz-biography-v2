---
title: 頂点バッファとレイアウト
created: "2025-04-29"
description: CPUからGPUへデータを渡す基本の仕組み
series: webgpu-concept
references:
  - title: WebGPU Buffer Uploads - Best practices
    url: https://toji.dev/webgpu-best-practices/buffer-uploads
  - title: WebGPU Vertex Buffers
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html
  - title: WebGPU Copying Data
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html
  - title: あらためて理解するArrayBuffer - JavaScriptでバイナリデータを扱う方法
    url: https://ics.media/entry/250408/
    summary: 今回登場した`Float32Array`などの型付き配列や、`ArrayBuffer`との関係について詳しく学びたい方におすすめの記事です。
  - title: ファイルとメモリーのマッピング (mmap)
    url: https://mkguytone.github.io/allocator-navigatable/ch68.html
    summary: Linuxの仕組みに関する記事ですが、「マッピング」のイメージを掴む上で参考になるかもしれません。
tags:
  - webgpu
  - wgsl
draft: true
---

> [!note]
>
> - https://chatgpt.com/c/68083090-b328-8000-85a5-10762d0c16d0

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGPUTriangleVertexBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle.png"

:SeriesPrevLink[前回]{series="webgpu-concept" current="webgpu-vertex-buffer"}は、WebGPUを使って三角形を描画する処理を完成させました。

ところで、三角形の頂点の座標は頂点シェーダ内で配列として定義していましたが、通常はこのようなことはしません。
なぜなら、頂点のデータをシェーダ内で定義してしまうと、そのシェーダはその図形専用のシェーダになってしまうからです。

シェーダは、コンパイルしてパイプラインに組み込むことで、初めて利用できるようになります。
WebGPUのパイプライン作成はそれなりに重い処理であり、図形ごとにシェーダとパイプラインを用意して切り替えながら描画するのは非効率です。

そこで今回は、JavaScript側で頂点座標を定義するようにコードを書き換えていきます。
そして、JavaScript（CPU側）で用意した頂点座標のデータをシェーダ（GPU側）に渡すための仕組みとして、==バッファ==を導入します。

## JavaScript側で頂点データを用意する

前回実装した三角形を描画するコードでは、頂点シェーダ内で定義した`pos{:wgsl}`という配列に、3つの頂点の座標を定義していました。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers{9} {3-7}
@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}
```

この頂点の座標（`pos{:wgsl}`の中身）を、JavaScript側で定義するようにしましょう。

単純に移植しようとすると、次のようなコードが思い浮かぶかもしれません。1つの頂点の座標を1つの配列とし、それを3つ並べた「配列の配列」です。

```js title="❌ JSによる頂点座標の定義"
const vertices = [
  [0.0, 0.5],
  [-0.5, -0.5],
  [0.5, -0.5]
]
```

1つの頂点ごとの座標をそれぞれ配列でまとめたこのコードは、人間にとってはわかりやすいものです。
しかし、GPU（シェーダ）に渡す場合は、次のようにフラット（flat）な1次元配列で定義するようにします。GPUのメモリ上にデータを並べる上で、そのほうが都合がよいのです。

```js title="❌ JSによる頂点座標の定義"
const vertices = [0.0, 0.5, -0.5, -0.5, 0.5, -0.5]
```

しかし、これでもまだGPU（シェーダ）に渡すには不十分です。
シェーダにデータを渡すときは、シェーダ側と各数値の型を合わせる必要があります。

WGSLによる頂点シェーダのコードでは、最終的に出力する座標`@builtin(position){:wgsl}`は`vec4f{:wgsl}`型と指定されています。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2}
struct VertexOutput {
  @builtin(position) Position: vec4f
};
```

`vec4f{:wgsl}`は`vec4<f32>{:wgsl}`の省略形であり、つまり座標を表す各数値は32ビット浮動小数点数（`f32{:wgsl}`型）であることを意味しています。

シェーダに座標データを正しく効率的に渡すには、JavaScript側でも、座標を表す各数値が32ビット浮動小数点数であることを明示する必要があるのです。
そのためには、通常の配列ではなく、`Float32Array{:js}`という型付きの配列を使います。

```js title="✅ JSによる頂点座標の定義"
const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
```

## CPUとGPUはメモリが分かれている

JavaScript側で頂点座標を定義した場合、厄介な問題に直面します。
それは、JavaScriptはCPU側で動くプログラムであり、一方でシェーダはGPU側で動くプログラムであるため、データの管理場所（メモリ空間）が異なることです。

基本的にCPU側のメモリとGPU側のメモリ（==デバイスメモリ==）は分かれていることが多く、GPU（シェーダ）からCPU側のメモリの内容（JavaScript側で定義したデータ）を直接参照することはできません。

JavaScript側で用意した頂点座標のデータをシェーダで使うためには、そのデータをGPUからアクセスできるメモリにコピーする必要があります。

## バッファを介したデータのやり取り

CPUとGPUの間でデータをやりとりする操作は、WebGPUでは「==バッファ==というオブジェクト（`GPUBuffer{:js}`）にデータを書き込む」という形で表現されます。

> [!note]
> 一般に、==バッファ==という言葉は、「データを一時的にためておく場所（メモリ領域）」という意味で使われます。

### バッファの作成

WebGPUのバッファを作成するには、`device.createBuffer(){:js}`メソッドを使います。

```js title="バッファを作成する"
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
})
```

バッファを作成する際には、「どこに」「どのくらいの」メモリ領域を確保したいのかを指定する必要があります。
WebGPUが「どこに」を判断するヒントとなるのが`usage{:js}`で、「どのくらいの」を明示するのが`size{:js}`です。

CPU用とGPU用のメモリが分かれているだけでなく、GPU側のメモリも用途に応じて分かれているため、GPUプログラミングでは、データをどのメモリ領域に置くかを明確に区別する必要があります。

WebGPUでは、バッファの作成時に`usage{:js}`フラグを指定することで、どのメモリ領域にデータを置くかをWebGPU側で判断してくれるようになっています。
フラグを複数指定する場合は、`|{:js}`（ビットOR）演算子でつなげて指定します。

- `VERTEX`：頂点データとして使う（GPU側のメモリを確保する）
- `COPY_DST`：コピー先（書き込み対象）として使う

今回は、`GPUBufferUsage.VERTEX{:js}`と`GPUBufferUsage.COPY_DST{:js}`という、2つのフラグを指定しました。
この組み合わせによって、「GPU側のメモリに頂点データ用の領域を確保し、CPU側からその領域にデータをコピーする」という意図をWebGPUに伝えています。

さて、バッファを作成しただけでは、バッファはただの空箱にすぎません。
作成したバッファにデータを書き込むには、`device.queue{:js}`が持つ`writeBuffer(){:js}`メソッドを使うのが便利です。

```js title="バッファにデータを書き込む"
device.queue.writeBuffer(vertexBuffer, 0, vertices)
```

`writeBuffer(){:js}`メソッドでは、ブラウザが最も効率のよい方法を判断し、データの書き込みを行ってくれます。

### 補足：互換性という「Webらしさ」

デバイスの種類に応じて、メモリの構成は異なります。スマートフォンなど一部のデバイスでは、GPUとCPUが同じメモリを共有していることもあります。

しかし、WebGPUのコードを書く上でそのような差異を気にする必要はありません。
WebGPUでは、すべての環境が「GPUとCPUが別々のメモリを持っている」という想定でコードを書くことができます。あとは、WebGPU側が動作環境に応じて最適化をしてくれるわけです。

このような設計になっているのは、WebGPUがWebブラウザ上で動くAPIだからです。WebGPU APIは、なるべく多くの種類のデバイスで同じコードが動作することを重視した設計になっています。

### 発展：作成時にマッピングして書き込む方法

先ほど解説したコードをまとめると、次のようなコードで頂点バッファの作成・書き込みを行っていました。

```js title="頂点バッファを作成して書き込む（非マップ方式）"
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
})
device.queue.writeBuffer(vertexBuffer, 0, vertices)
```

このコードの代わりに、次のようなコードスニペットによって、頂点バッファの作成・書き込みを行うこともできます。

```js title="頂点バッファを作成して書き込む（作成時マッピング方式）"
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()
```

インターネットで調べると出てくるWebGPUのサンプルコードでは、むしろこちらのコードスニペットの方がよく見かけるかもしれません。

この新たな方法に登場する、未知の部分に注目してみましょう。

```js title="頂点バッファを作成して書き込む（作成時マッピング方式）" {4,6-9}
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()
```

まず、`mappedAtCreation: true{:js}`を指定することで、バッファの作成時に==マッピング==も同時に行います。
==マッピング==とは、GPU側のメモリをCPUから直接アクセスできるようにし、まるでCPUメモリの一部のように扱える状態にすることです。

```js {4}
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX,
  mappedAtCreation: true
})
```

これで、バッファの作成後すぐに、JavaScript側から中身を直接書き込めるようになります。実際にデータの書き込みを行っているのが、次の行です。

```js
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
```

`getMappedRange(){:js}`メソッドでは、バッファの書き込み可能な範囲のメモリ領域をJavaScriptの`ArrayBuffer{:js}`オブジェクトとして取得します。

```js
vertexBuffer.getMappedRange()
```

ただし、`ArrayBuffer{:js}`オブジェクトが扱うのは、ただのバイナリデータです。
何バイトで1つの数値を表すのかは数値型によって異なるため、このバイナリデータを意味のある値として扱うためには、型付き配列でラップする必要があります。

ここでは、得られたメモリ領域を32ビット浮動小数点数の配列として扱うために、`Float32Array{:js}`コンストラクタでラップしています。

```js
new Float32Array(vertexBuffer.getMappedRange())
```

これで、GPU側のメモリ領域を、JavaScript側から32ビット浮動小数点数の配列として扱えるようになりました。
あとは、`set(){:js}`メソッドを使って、JavaScript側で用意した頂点データ（`vertices{:js}`）を直接書き込みます。

```js
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
```

書き込みが終わったら、マッピングを解除して、GPUにメモリのアクセス権を返します。
WebGPUでは、マッピング状態のままだとGPU側がそのバッファを使えないので、次の`unmap(){:js}`でロックを外す必要があります。

```js
vertexBuffer.unmap()
```

最後に、`usage{:js}`フラグから`COPY_DST{:js}`を外していることに注意してください。
GPU側のメモリに直接書き込むこの方式では、CPU側からGPU側へのデータのコピーが行われないため、`COPY_DST{:js}`は不要になります。

```js {3}
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX,
  mappedAtCreation: true
})
```

この作成時マッピング方式は、特にCPU側で動的に頂点データを生成する場合に効率がよい方法です。
JavaScriptの配列を作ってからGPU側のメモリにコピーするのではなく、GPU側のメモリへ直接書き込みながら処理を進めることで、余計なメモリコピーを省くことができます。

```js title="例：トーラスの頂点バッファを作成する" showLineNumbers {7-11,13,31-34,38}
function generateTorusVertexBuffer({
  radius = 1.0, // トーラスの中心からチューブ中心までの距離
  tubeRadius = 0.4, // チューブ自体の半径
  radialSegments = 32, // 外側リングの分割数
  tubularSegments = 24 // チューブ側の分割数
} = {}) {
  const vertexBuffer = device.createBuffer({
    size: Float32Array.BYTES_PER_ELEMENT * 3 * (radialSegments + 1) * (tubularSegments + 1),
    usage: GPUBufferUsage.VERTEX,
    mappedAtCreation: true
  })

  const vertices = new Float32Array(vertexBuffer.getMappedRange())

  for (let j = 0; j <= radialSegments; j++) {
    const v = (j / radialSegments) * Math.PI * 2

    const cosV = Math.cos(v)
    const sinV = Math.sin(v)

    for (let i = 0; i <= tubularSegments; i++) {
      const u = (i / tubularSegments) * Math.PI * 2

      const cosU = Math.cos(u)
      const sinU = Math.sin(u)

      const x = (radius + tubeRadius * cosV) * cosU
      const y = (radius + tubeRadius * cosV) * sinU
      const z = tubeRadius * sinV

      // 直接書き込み
      vertices[(j * (tubularSegments + 1) + i) * 3 + 0] = x
      vertices[(j * (tubularSegments + 1) + i) * 3 + 1] = y
      vertices[(j * (tubularSegments + 1) + i) * 3 + 2] = z
    }
  }

  vertexBuffer.unmap()

  return vertexBuffer
}
```

注意点として、`mappedAtCreation: true{:js}`による作成時マッピング方式は、バッファの内容を後から変更しない場合にしか使うことができません。
バッファを使い回して内容だけ書き換えるような場合には、`queue.writeBuffer(){:js}`による非マップ方式を使う必要があります。

> [!warning]
> 実は、ここでの説明はかなり簡略化してしまっています。
> 実際は、GPU側のメモリに直接書き込むことはできないため、CPUからアクセスできる中間メモリ（==ステージングバッファ==）に対してマッピング・書き込みを行い、そこからGPU側のメモリにコピーするという仕組みになっています。
> 現時点ではステージングバッファの存在を意識する必要はないため、このような説明に留めておきました。
> 後のコンピュートシェーダに関する回では、ステージングバッファを介したデータのやり取りについてもう少し深掘りすることになります。

## バッファの中身とレイアウト

バッファの中身は、ただの連続したバイナリデータです。たとえば、`[0.0, 1.0, 0.0, 1.0]` のような浮動小数点数（`Float32`）がずらっと並んでいたり、`[1, 2, 3, 4]` のような整数列だったりします。

しかし、GPUはこの数値の並びを「色」や「座標」として直接理解してくれるわけではありません。「このバッファのこの位置には、このようなデータが入っている」という説明（==デスクリプタ==）を一緒に渡す必要があります。
たとえば、「1つの頂点には、位置を表す3つの数値（`x, y, z`）と、色を表す4つの数値（`r, g, b, a`）があります」というような情報を、==デスクリプタ==というオブジェクトで教えてあげることで、GPUはバッファの中身を正しく解釈できるようになるのです。

頂点バッファに関するデスクリプタは、2種類に分けられています。

- ==属性デスクリプタ==：1つの頂点に関するデータの並びの説明（ローカルな情報）
- ==レイアウトデスクリプタ==：バッファに格納された全頂点に関するデータの並びの説明（グローバルな情報）

### 属性デスクリプタ

頂点バッファでは、各頂点の位置だけでなく、その頂点の色や、その頂点に対応するテクスチャの座標なども一緒に格納する場合もあります。
このような、位置、色、テクスチャ座標など、1つの頂点に関する情報を==属性==と呼ぶことがあります。

==属性デスクリプタ==は、1つの頂点が持つ属性の「データの配置場所（`@location{:wgsl}`）」や「データ型（`vec3<f32>{:wgsl}`など）」を記述するものです。

### レイアウトデスクリプタ

GPUに頂点データを送るとき、通常は複数の頂点をまとめた大きなバッファを一気に送信します。少量のデータを小分けで送るのは効率が悪いため、このようなバッチ送信が基本となります。
しかし、「1つの頂点ずつ」処理する頂点シェーダーでは、バッファ全体の情報を一度に見ることはできません。

==レイアウトデスクリプタ==は、多くの頂点がまとめて格納されたバッファから、「各頂点のデータをどう取り出すか」というルールを定義するものです。

GPUは、レイアウトデスクリプタをもとに、各頂点に必要なデータをバッファから自動的に切り出し、シェーダの処理に使います。

## 用意した頂点バッファを使う

### 頂点バッファを使って描画するように設定

### シェーダで頂点データを受け取る

## 実装コード全文：頂点バッファを使った三角形の描画

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2,12}
struct VertexInput {
  @location(0) position: vec2f
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  out.Position = vec4f(in.position, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```js title="JavaScriptによるWebGPUのコード" showLineNumbers {10-15,24-35,61}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas!.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
})
device.queue.writeBuffer(vertexBuffer, 0, vertices)

const shaderModule = device.createShaderModule({ code: shaderCode })

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main",
    buffers: [
      {
        arrayStride: vertices.BYTES_PER_ELEMENT * 2,
        attributes: [
          {
            shaderLocation: 0,
            offset: 0,
            format: "float32x2"
          }
        ]
      }
    ]
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [
      {
        format: canvasFormat
      }
    ]
  }
})

const commandEncoder = device.createCommandEncoder()

const renderPass = commandEncoder.beginRenderPass({
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.749, g: 0.925, b: 1.0, a: 1 },
      storeOp: "store"
    }
  ]
})
renderPass.setPipeline(renderPipeline)
renderPass.setVertexBuffer(0, vertexBuffer)
renderPass.draw(3)
renderPass.end()

device.queue.submit([commandEncoder.finish()])
```

実行結果は次のようになります。

<DemoLinkWithResult
  url="https://tomixyz-sketchbook.pages.dev/basics/webgpu-triangle-vertex-buffer/"
  result={img_WebGPUTriangleVertexBuffer}
  title="頂点バッファを使って三角形を描画するデモ"
/>
