---
title: 頂点バッファとレイアウト
date: "2025-04-28"
description: CPUからGPUへデータを渡す基本の仕組み
series: webgpu-concept
references:
  - title: あらためて理解するArrayBuffer - JavaScriptでバイナリデータを扱う方法
    url: https://ics.media/entry/250408/
    summary: 今回登場した`Float32Array`など、JavaScriptの型付き配列について詳しく学びたい方におすすめの記事です。
  - title: WebGPU Vertex Buffers
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html
  - title: WebGPU Buffer Uploads - Best practices
    url: https://toji.dev/webgpu-best-practices/buffer-uploads
  - title: WebGPU Copying Data
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html
  - title: WebGPU Bind Group Layouts
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html
tags:
  - webgpu
  - wgsl
draft: true
---

> [!note]
>
> - https://chatgpt.com/c/6806e75b-a60c-8000-a5e8-66fb838d8749
> - https://chatgpt.com/c/6807595b-4fe4-8000-bf42-24caa3c7069b
> - https://chatgpt.com/c/68083090-b328-8000-85a5-10762d0c16d0
> - https://chatgpt.com/c/680b171a-f2f4-8000-acee-572a8eb01376

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGPUTriangleVertexBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle.png"

:SeriesPrevLink[前回]{series="webgpu-concept" current="webgpu-vertex-buffer"}は、WebGPUを使って三角形を描画する処理を完成させました。

ところで、三角形の頂点の座標は頂点シェーダ内で配列として定義していましたが、通常はこのようなことはしません。
なぜなら、頂点のデータをシェーダ内で定義してしまうと、そのシェーダはその図形専用のシェーダになってしまうからです。

シェーダは、コンパイルしてパイプラインに組み込むことで、初めて利用できるようになります。
WebGPUのパイプライン作成はそれなりに重い処理であり、図形ごとにシェーダとパイプラインを用意して切り替えながら描画するのは非効率です。

そこで今回は、JavaScript側で頂点座標を定義するようにコードを書き換えていきます。
そして、JavaScript側で用意した頂点座標のデータをGPU（シェーダ）に渡すための仕組みとして、==バッファ==を導入します。

## CPUとGPUはメモリが分かれている

JavaScript側で頂点座標を定義した場合、厄介な問題に直面します。
それは、JavaScriptはCPU側で動くプログラムであり、一方でシェーダはGPU側で動くプログラムであるため、データの管理場所（メモリ空間）が異なることです。

基本的にCPU側のメモリとGPU側のメモリ（==デバイスメモリ==）は分かれていることが多く、GPU（シェーダ）からCPU側のメモリの内容（JavaScript側で定義したデータ）を直接参照することはできません。

JavaScript側で用意した頂点座標のデータをシェーダで使うためには、そのデータをGPUからアクセスできるメモリにコピーする必要があります。

## バッファを介したデータのやり取り

CPUとGPUの間でデータをやりとりする操作は、WebGPUでは「==バッファ==というオブジェクト（`GPUBuffer{:js}`）にデータを書き込む」という形で表現されます。

> [!note]
> 一般に、==バッファ==という言葉は、「データを一時的にためておく場所（メモリ領域）」という意味で使われます。

### 補足：互換性という「Webらしさ」

スマートフォンなど一部のデバイスでは、GPUとCPUが同じメモリを共有していることもありますが、WebGPUのコードを書く上でそのような差異を気にする必要はありません。
WebGPUでは、すべての環境が「GPUとCPUが別々のメモリを持っている」という想定でコードを書くことができます。あとは、WebGPU内部で環境に応じて最適化をしてくれるわけです。

このような設計になっているのは、WebGPUがWebブラウザ上で動くAPIだからです。WebGPU APIは、なるべく多くの種類のデバイスで同じコードが動作することを重視した設計になっています。

## JS側で頂点データを定義する

前回実装した三角形を描画するコードでは、頂点シェーダ内で定義した`pos{:wgsl}`という配列に、3つの頂点の座標を定義していました。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers{9} {3-7}
@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}
```

この頂点の座標（`pos{:wgsl}`の中身）を、JavaScript側で定義するようにしましょう。

単純に移植しようとすると、次のようなコードが思い浮かぶかもしれません。1つの頂点の座標を1つの配列とし、それを3つ並べた「配列の配列」です。

```js title="❌ JSによる頂点座標の定義"
const vertices = [
  [0.0, 0.5],
  [-0.5, -0.5],
  [0.5, -0.5]
]
```

1つの頂点ごとの座標をそれぞれ配列でまとめたこのコードは、人間にとってはわかりやすいものです。
しかし、GPUにバッファとして渡すときは、次のようにフラット（flat）な1次元配列で定義するようにします。GPUからアクセスできるメモリ上にデータを並べる上で、そのほうが都合がよいのです。

```js title="❌ JSによる頂点座標の定義"
const vertices = [0.0, 0.5, -0.5, -0.5, 0.5, -0.5]
```

しかし、これでもまだGPU（シェーダ）に渡すには不十分です。
シェーダにデータを渡すときは、シェーダ側と各数値の型を合わせる必要があります。

WGSLによる頂点シェーダのコードでは、最終的に出力する座標`@builtin(position){:wgsl}`は`vec4f{:wgsl}`型と指定されています。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2}
struct VertexOutput {
  @builtin(position) Position: vec4f
};
```

`vec4f{:wgsl}`は`vec4<f32>{:wgsl}`の省略形であり、つまり座標を表す各数値は32ビット浮動小数点数（`f32{:wgsl}`型）であることを意味しています。

シェーダに座標データを正しく効率的に渡すには、JavaScript側でも、座標を表す各数値が32ビット浮動小数点数であることを明示する必要があるのです。
そのためには、通常の配列ではなく、`Float32Array{:js}`という型付きの配列を使います。

```js title="✅ JSによる頂点座標の定義"
const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
```

## 頂点データのためのバッファを作る

この`vertices{:js}`配列をGPUに渡すためには、バッファを作成して、そこにデータを書き込んでおく必要があります。

WebGPUでバッファを作るには、`device.createBuffer()` という関数を使います。このとき、どのような使い方をするかを `usage` というフラグで明示します。たとえば：

- **`VERTEX`**：頂点データとして使う
- **`COPY_SRC` / `COPY_DST`**：他のバッファやテクスチャとの間でコピーするために使う

このように、**どう使うかを最初から明示する**のがWebGPUの基本スタイルです。

```js
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
})
device.queue.writeBuffer(vertexBuffer, 0, vertices)
```

## 発展：バッファへの書き込み手法いろいろ

以後変更されないバッファは、`mappedAtCreation: true`を指定して、バッファを作成したときにマッピングする方法も使える
この方法は、CPU側で動的に頂点データを生成する場合に効率がよい

```js
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()
```

よく使われるのが、`mappedAtCreation: true` を指定して作成時にマッピングし、JavaScript側からバッファのメモリに直接書き込む方法です。

ここで `getMappedRange()` によって得られるのは、生のメモリ領域です。そこに `Float32Array` などを使ってデータを書き込み、`unmap()` を呼ぶことで、GPU側で利用可能な状態になります。

なお、バッファを使い回して内容だけ書き換えるような場合には、非マップ方式で `queue.writeBuffer()` を使う方法もあります。

## バッファの中身とレイアウト

バッファの中身は、**ただの連続したバイナリデータ**です。たとえば、`[0.0, 1.0, 0.0, 1.0]` のような浮動小数点数（`Float32`）がずらっと並んでいたり、`[1, 2, 3, 4]` のような整数列だったりします。

でもGPUはそれを「色」や「座標」として直接理解してくれるわけではないので、**「このバッファのこの場所には、何のデータが入っているのか」を一緒に伝える必要**があります。

これが「レイアウト（layout）」です。たとえば「1つの頂点には、位置が3つ（X, Y, Z）、色が4つ（R, G, B, A）あります」というような情報を、プログラム側で教えてあげることで、GPUはバッファの中身を正しく解釈できます。

- パイプラインレイアウトについても触れる（`auto`ではない書き方）

## 補足：なぜ明示的な管理が必要なのか？

WebGLでは、バッファを作るときや使うときにあまり多くの情報を指定する必要はありませんでした。`gl.createBuffer()`で作り、`gl.bufferData()`で書き込むだけです。ただしその裏では、多くの状態や挙動が暗黙的に処理されており、「なぜこの描画が失敗したのか」がわかりづらいこともよくありました。

WebGPUでは逆に、**バッファを作成する時点で細かい指定が必要**になります。その分、開発者が意図をはっきり伝えることができ、GPU側でも最適なリソースの準備がしやすくなります。これはパフォーマンスやメモリ効率の面でも重要なポイントです。

## 実装：頂点バッファを使った三角形の描画

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2,12}
struct VertexInput {
  @location(0) position: vec2f
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  out.Position = vec4f(in.position, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```js title="JavaScriptによるWebGPUのコード" showLineNumbers {10-15,24-35,61}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas!.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
})
device.queue.writeBuffer(vertexBuffer, 0, vertices)

const shaderModule = device.createShaderModule({ code: shaderCode })

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main",
    buffers: [
      {
        arrayStride: vertices.BYTES_PER_ELEMENT * 2,
        attributes: [
          {
            shaderLocation: 0,
            offset: 0,
            format: "float32x2"
          }
        ]
      }
    ]
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [
      {
        format: canvasFormat
      }
    ]
  }
})

const commandEncoder = device.createCommandEncoder()

const renderPass = commandEncoder.beginRenderPass({
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.749, g: 0.925, b: 1.0, a: 1 },
      storeOp: "store"
    }
  ]
})
renderPass.setPipeline(renderPipeline)
renderPass.setVertexBuffer(0, vertexBuffer)
renderPass.draw(3)
renderPass.end()

device.queue.submit([commandEncoder.finish()])
```

実行結果は次のようになります。

<DemoLinkWithResult
  url="https://tomixyz-sketchbook.pages.dev/basics/webgpu-triangle-vertex-buffer/"
  result={img_WebGPUTriangleVertexBuffer}
  title="頂点バッファを使って三角形を描画するデモ"
/>
