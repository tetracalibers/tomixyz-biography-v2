---
title: 頂点バッファとレイアウト
date: "2025-04-22"
description: CPUからGPUへデータを渡す基本の仕組み
series: webgpu-concept
references:
  - title: あらためて理解するArrayBuffer - JavaScriptでバイナリデータを扱う方法
    url: https://ics.media/entry/250408/
  - title: WebGPU Vertex Buffers
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html
  - title: WebGPU Buffer Uploads - Best practices
    url: https://toji.dev/webgpu-best-practices/buffer-uploads
  - title: WebGPU Copying Data
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-copying-data.html
  - title: WebGPU Bind Group Layouts
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html
tags:
  - webgpu
  - wgsl
draft: true
---

> [!note]
>
> - https://chatgpt.com/c/6806e75b-a60c-8000-a5e8-66fb838d8749
> - https://chatgpt.com/c/6807595b-4fe4-8000-bf42-24caa3c7069b
> - https://chatgpt.com/c/68083090-b328-8000-85a5-10762d0c16d0

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGPUTriangleVertexBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle-vertex-buffer.png"

:SeriesPrevLink[前回]{series="webgpu-concept" current="webgpu-vertex-buffer"}は、WebGPUを使って三角形を描画する処理を完成させました。

ところで、三角形の頂点の座標は頂点シェーダ内で配列として定義していましたが、通常はこのようなことはしません。
なぜなら、頂点のデータをシェーダ内で定義してしまうと、そのシェーダはその図形専用のシェーダになってしまうからです。

シェーダは、コンパイルしてパイプラインに組み込むことで、初めて利用できるようになります。
WebGPUのパイプライン作成はそれなりに重い処理であり、図形ごとにシェーダとパイプラインを用意して切り替えながら描画するのは非効率です。

そこで、GPUにデータを渡すための仕組みとして、==バッファ==を導入します。

## バッファを介したデータのやり取り

一般に、==バッファ==とは、直接やり取りするには速度やタイミングが合わない時に、=p=データを一時的にためておく場所==（メモリ領域）を指します。

==バッファ==とは、GPUからアクセスできるメモリ上のデータ列を表すオブジェクトです。簡単に言えば**GPUに渡すためのデータを入れておく箱のようなもの**です。もう少し正確に言うと、**GPUが使うためのメモリ領域**を意味します。

頂点の座標や色などの情報は、普通はシェーダとは別にデータとして用意して、シェーダに渡します。

しかし、シェーダは普通のプログラムと違い、CPU上ではなくGPU上で動くプログラムです。そのため、普通のメモリ上にある変数の値などは基本的に読み込めません。
シェーダにデータを渡すためには、データを==GPUからアクセスできるメモリ==に置いておく必要があります。

GPUから普通のメモリの内容は参照できないため、シェーダで使いたいデータがある場合、まずGPUからアクセス可能なメモリに移す必要があります。そしてそれはプログラムの上では「バッファに書き込む」「バッファに書き込んで転送する」という形になります。

### WebGPUが扱うメモリ

WebGPUは大きく分けて、2種類のメモリを扱っていると考えることができます。

- ==GPUからアクセス可能==なメモリ
- ==CPUからアクセス可能==で、GPUに効率よくコピーできるメモリ

シェーダからデータにアクセスしたいときは、そのデータは==GPUからアクセス可能なメモリ==にある必要があります。
一方、JavaScriptからデータにアクセスしたい場合は、そのデータは==CPUからアクセス可能なメモリ==に存在している必要があります。

### 補足：互換性という「Webらしさ」

スマートフォンなど一部のデバイスでは、GPUとCPUが同じメモリを共有していることもあります。
しかし、WebGPUはWeb上で動くAPIなので、=p=なるべく多くの種類のデバイスで同じコードが動作する==ことを重視します。
そのため、WebGPUはすべての環境が「GPUとCPUが別々のメモリを持っている」と仮定してコードを書かせるようになっています。あとは、WebGPU内部で環境に応じて最適化をしてくれるわけです。

## JS側で頂点データを定義する

前回実装した三角形を描画するコードでは、頂点シェーダ内で定義した`pos{:wgsl}`という配列に、3つの頂点の座標を定義していました。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers{9} {3-7}
@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}
```

この頂点の座標（`pos{:wgsl}`の中身）を、JavaScript側で定義するようにしましょう。

愚直に写し書きするだけなら、次のようなコードが思い浮かぶかもしれません。1つの頂点の座標を1つの配列とし、それを3つ並べた「配列の配列」です。

```js title="❌ JSによる頂点座標の定義"
const vertices = [
  [0.0, 0.5],
  [-0.5, -0.5],
  [0.5, -0.5]
]
```

1つの頂点ごとの座標をそれぞれ配列でまとめたこのコードは、人間にとってはわかりやすいものです。
しかし、GPUにバッファとして渡すときは、次のようにフラット（flat）な1次元配列で定義するようにします。GPUからアクセスできるメモリ上にデータを並べる上で、そのほうが都合がよいのです。

```js title="❌ JSによる頂点座標の定義"
const vertices = [0.0, 0.5, -0.5, -0.5, 0.5, -0.5]
```

しかし、これでもまだGPU（シェーダ）に渡すには不十分です。
シェーダにデータを渡すときは、シェーダ側と各数値の型を合わせる必要があります。

WGSLによる頂点シェーダのコードでは、最終的に出力する座標`@builtin(position){:wgsl}`は`vec4f{:wgsl}`型と指定されています。

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2}
struct VertexOutput {
  @builtin(position) Position: vec4f
};
```

`vec4f{:wgsl}`は`vec4<f32>{:wgsl}`の省略形であり、つまり座標を表す各数値は32ビット浮動小数点数（`f32{:wgsl}`型）であることを意味しています。

シェーダに座標データを正しく効率的に渡すには、JavaScript側でも、座標を表す各数値が32ビット浮動小数点数であることを明示する必要があるのです。
そのためには、通常の配列ではなく、`Float32Array{:js}`という型付きの配列を使います。

```js title="✅ JSによる頂点座標の定義"
const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
```

## 頂点データのためのバッファを作る

この`vertices{:js}`配列をGPUに渡すためには、バッファを作成して、そこにデータを書き込んでおく必要があります。

```js
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()
```

## 補足：バッファへの書き込み手法

- `mappedAtCreation: true`を指定して、バッファを作成したときにマッピングする方法
- `queue.writeBuffer()`を使って、バッファにデータを書き込む方法

## 発展：データの読み書きの裏側

これらのステップの一部は、WebGPU の便利メソッドが**裏で自動的にやってくれる**場合もあります。  
でも、ほとんどのケースではこの流れが基本になっていると考えてOKです。

### データをGPU用のメモリに送る流れ

GPU用のメモリにデータを送るには、以下のような一連のステップが使われます：

1. **ステージングバッファ**（CPU アクセス可能なバッファ）を作る  
   使用目的は `GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC`
2. `mapAsync()` を使って書き込み用にマッピングする（JavaScript の `ArrayBuffer` として扱えるようになる）
3. データを `ArrayBuffer` に書き込む
4. バッファのマッピングを解除する（unmap）
5. `copyBufferToBuffer()` または `copyBufferToTexture()` を使って、GPU 用のメモリにコピーする

### GPU用のメモリからデータを読み出す流れ

逆に、GPU のメモリからデータを読むときも似たような流れになります：

1. **ステージングバッファ**（CPU 読み出し用）を作る  
   使用目的は `GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST`
2. `copyBufferToBuffer()` や `copyTextureToBuffer()` で GPU メモリからステージングバッファにコピーする
3. `mapAsync()` を使って読み出し用にマッピングする（JavaScript の `ArrayBuffer` として読めるようになる）
4. データを `ArrayBuffer` から読み出す
5. バッファのマッピングを解除する

## バッファの中身とレイアウト

バッファの中身は、**ただの連続したバイナリデータ**です。たとえば、`[0.0, 1.0, 0.0, 1.0]` のような浮動小数点数（`Float32`）がずらっと並んでいたり、`[1, 2, 3, 4]` のような整数列だったりします。

でもGPUはそれを「色」や「座標」として直接理解してくれるわけではないので、**「このバッファのこの場所には、何のデータが入っているのか」を一緒に伝える必要**があります。

これが「レイアウト（layout）」です。たとえば「1つの頂点には、位置が3つ（X, Y, Z）、色が4つ（R, G, B, A）あります」というような情報を、プログラム側で教えてあげることで、GPUはバッファの中身を正しく解釈できます。

- パイプラインレイアウトについても触れる（`auto`ではない書き方）

---

## [DRAFT]

## なぜ明示的な管理が必要なのか？

WebGLでは、バッファを作るときや使うときにあまり多くの情報を指定する必要はありませんでした。`gl.createBuffer()`で作り、`gl.bufferData()`で書き込むだけです。ただしその裏では、多くの状態や挙動が暗黙的に処理されており、「なぜこの描画が失敗したのか」がわかりづらいこともよくありました。

WebGPUでは逆に、**バッファを作成する時点で細かい指定が必要**になります。その分、開発者が意図をはっきり伝えることができ、GPU側でも最適なリソースの準備がしやすくなります。これはパフォーマンスやメモリ効率の面でも重要なポイントです。

## バッファの作成と用途指定

WebGPUでバッファを作るには、`device.createBuffer()` という関数を使います。このとき、どのような使い方をするかを `usage` というフラグで明示します。たとえば：

- **`VERTEX`**：頂点データとして使う
- **`COPY_SRC` / `COPY_DST`**：他のバッファやテクスチャとの間でコピーするために使う

このように、**どう使うかを最初から明示する**のがWebGPUの基本スタイルです。

## バッファにデータを渡す方法

WebGPUでは、バッファにデータを渡す方法も明示的です。よく使われるのが、`mappedAtCreation: true` を指定して作成時にマッピングし、JavaScript側からバッファのメモリに直接書き込む方法です。

```js
const buffer = device.createBuffer({
  size: 256,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})

const arrayBuffer = buffer.getMappedRange()
new Float32Array(arrayBuffer).set([1.0, 0.0, 0.0, 1.0])
buffer.unmap()
```

ここで `getMappedRange()` によって得られるのは、生のメモリ領域です。そこに `Float32Array` などを使ってデータを書き込み、`unmap()` を呼ぶことで、GPU側で利用可能な状態になります。

なお、バッファを使い回して内容だけ書き換えるような場合には、非マップ方式で `queue.writeBuffer()` を使う方法もあります。

## バッファの破棄とメモリ管理

WebGPUの設計では、リソースは**自動で破棄されることを前提としません**。使い終わったバッファは明示的に `buffer.destroy()` を呼んで破棄するのが望ましいです。これにより、不要になったGPUメモリを確実に解放でき、メモリリークのリスクを減らせます。

---

## 実装：頂点バッファを使った三角形の描画

```wgsl title="WGSLによるシェーダのコード" showLineNumbers {2,12}
struct VertexInput {
  @location(0) position: vec2f
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var out: VertexOutput;
  out.Position = vec4f(in.position, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```js title="JavaScriptによるWebGPUのコード" showLineNumbers {10-17,26-37,63}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas!.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5])
const vertexBuffer = device.createBuffer({
  size: vertices.byteLength,
  usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  mappedAtCreation: true
})
new Float32Array(vertexBuffer.getMappedRange()).set(vertices)
vertexBuffer.unmap()

const shaderModule = device.createShaderModule({ code: shaderCode })

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main",
    buffers: [
      {
        arrayStride: vertices.BYTES_PER_ELEMENT * 2,
        attributes: [
          {
            shaderLocation: 0,
            offset: 0,
            format: "float32x2"
          }
        ]
      }
    ]
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [
      {
        format: canvasFormat
      }
    ]
  }
})

const commandEncoder = device.createCommandEncoder()

const renderPass = commandEncoder.beginRenderPass({
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.32, g: 0.34, b: 0.36, a: 1 },
      storeOp: "store"
    }
  ]
})
renderPass.setPipeline(renderPipeline)
renderPass.setVertexBuffer(0, vertexBuffer)
renderPass.draw(3)
renderPass.end()

device.queue.submit([commandEncoder.finish()])
```

実行結果は次のようになります。

<DemoLinkWithResult
  url="https://tomixyz-sketchbook.pages.dev/basics/webgpu-triangle-vertex-buffer/"
  result={img_WebGPUTriangleVertexBuffer}
  title="頂点バッファを使って三角形を描画するデモ"
/>
