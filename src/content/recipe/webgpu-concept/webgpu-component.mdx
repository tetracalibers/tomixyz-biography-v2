---
title: WebGPUの抽象化レイヤー
date: "2025-04-13"
description: GPUの抽象化であるアダプタとデバイスについて
series: webgpu-concept
references:
  - title: WebGPU from WebGL
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-from-webgl.html
  - title: Drawing a Triangle with WebGPU
    url: https://carmencincotti.com/2022-04-18/drawing-a-webgpu-triangle/
tags:
  - webgpu
  - webgl
draft: true
---

WebGLはグラフィックスAPIという位置づけでしたが、WebGPUはグラフィックスに限らず、GPUで処理を行うこと自体を目的としたAPIです。
そのため、WebGPUの初期化は、`canvas`要素に何かを描くためのコンテキストの用意だけでなく、GPUに安全にアクセスするための抽象化された手順から始まります。

## 物理的なGPUと論理的なGPU

実際にハードウェアに搭載されているGPU（==物理的なGPU==）の数は限られています。
しかし、GPUは同時にたくさんのアプリケーションから使われています。

そのため、GPUを使っている各アプリが他と干渉しないように、安全にGPUを共有する必要があります。
そうしないと、他のアプリの描画を邪魔したり、こっそりデータを読むような悪意ある動作も起きかねません。

### 多重化 (multiplexing)

==多重化==とは、1つのリソースを、あたかも複数あるかのように扱い、安全に共有するための仕組みです。

WebGPUには、たとえ1つの物理的なGPUを共有していたとしても、各Webアプリからは、あたかも自分だけが自分専用のGPU（==論理的なGPU==）を使っているかのように見せる仕組みがあります。=p=論理的には専用に見えても、物理的には共有されている==わけです。

### WebGPUによる抽象化：アダプタと論理デバイス

WebGPUで何らかの処理を行いたいとき、まずはGPUとやりとりするための窓口を準備する必要があります。

1. ハードウェアに搭載されている=p=物理的なGPU==（==アダプタ==）の情報を取得する
2. 物理的なGPUから、アプリに割り当てられた=p=論理的なGPU==（==論理デバイス==）を取得する

WebGPUでは、物理的なGPUに対応する概念が==アダプタ==で、論理的なGPUに対応する概念が==論理デバイス==です。このアダプタと論理デバイスという抽象化によって、GPUへのアクセスを安全に確立することができます。

| 用語     | たとえると        | 実体は          | 何を表してるか                             |
| -------- | ----------------- | --------------- | ------------------------------------------ |
| アダプタ | GPUそのもの       | **物理的なGPU** | PCに載ってるGPUチップそのもの              |
| デバイス | GPUの操作ハンドル | **論理的なGPU** | アプリがそのGPUをどう使うか（1プロセス内） |

## アダプタ (Adapter)

パソコンやスマートフォンには、複数のGPU（たとえばCPU内蔵の省電力GPUと、外部の高性能GPU）があることがあります。WebGPUを使うには、まずその中からどのGPUを使うか選ぶ必要があります。

WebGPUの==アダプタ==は、PCに搭載された=p=実際のGPU（物理的なGPU）==を表すものです。
アダプタを取得することで、物理的なGPUの名前や性能、対応している機能などがわかります。

### アダプタの取得

WebGPUの初期化ではまず、次のようにしてアダプタを取得します。

```js
const adapter = await navigator.gpu.requestAdapter()
```

`requestAdapter()`は、ブラウザに「使えるGPUを教えて！」と依頼する処理です。
結果として、使えるGPUに関する情報を持つ`GPUAdapter`オブジェクトが返ってきます。

### アダプタが持つ情報

取得したアダプタからは、たとえば以下の情報がわかります：

- `adapter.features` → サポートしている機能（例：depth-clamping、timestamp-queryなど）
- `adapter.limits` → リソース制限（例：最大テクスチャサイズ、バインディング数など）

これを見れば、そのGPUがどれくらい性能があるか、どんな機能が使えるかがわかります。

- [demo: WebGPUアダプタが持つ情報の確認](/demo/webgpu-adapter-info)

### アダプタ取得時のオプション

`requestAdapter()` にはオプションを渡すことができます：

```js
const adapter = await navigator.gpu.requestAdapter({
  powerPreference: "high-performance" // または "low-power"
})
```

- `"high-performance"`：できれば外部GPUを使いたい（高性能）
- `"low-power"`：バッテリー消費を抑えたい（内蔵GPU）

ただしこれは**希望を伝えるだけ**で、必ずその通りになるわけではありません。

---

**アダプタ（Adapter）**は、**OSのネイティブなグラフィックスAPIをWebGPUに翻訳するためのレイヤー（層）**です。

アダプタは「OSから見たGPU情報」と「WebGPUで使える形式」をつなぐ**橋渡し**のようなものです。

## 論理デバイス (Device)

**ブラウザはOSから見れば1つのアプリケーションですが、その中で複数のWebアプリを同時に実行できます。**  
そのため、**Webアプリごとに個別にGPUを使っているように見せる仕組みがまた必要**になります。

たとえば、複数のタブでそれぞれWebGPUを使っていたら、それぞれが**「自分だけがGPUを使ってる」と思い込める必要**があります。

それを表現するために、WebGPUでは**論理デバイス（logical device）**という仕組みを導入しています。

この「論理デバイス」が、**それぞれのWebアプリ専用に見えるGPUインターフェース**というわけです。

- **デバイス（とくに論理デバイス）**は、「アプリが使うGPUの仮想的な操作ハンドル」。
- WebGPUでは、**各Webアプリが安全にGPUを使えるように、論理デバイスの仕組みが重要**。

| 用語           | 意味                                                                                                         |
| -------------- | ------------------------------------------------------------------------------------------------------------ |
| WebGPUでの工夫 | 複数のWebアプリに「それぞれ専用のGPUがあるように見せる」ため、論理デバイスを使ってマルチプレクシングしている |

**デバイスは、GPUとやりとりするための入り口（コントローラー）です。**

- そのアダプタ上で使うための**GPUへの論理的なアクセス権（ハンドル）**です。
- アプリごとに1つ作るのが基本（スレッド間共有もあり得る）。
- バッファ、テクスチャ、パイプラインなどを作るにはこのデバイスが必要。

この `device` を通して、実際のGPUに命令を出したり、リソースを作ったりします。

WebGPUでGPUを使って描画や計算をするには、最初に「デバイス」というものを手に入れる必要があります。このデバイスを通して、バッファを作ったり、シェーダーを動かしたり、描画コマンドを送ったりします。

### **なぜデバイスが必要なの？**

GPUは非常に強力なハードウェアですが、いきなりプログラムからアクセスすることはできません。WebGPUでは、このアクセスの「仲介役」として`GPUDevice`を使います。

- GPUの「操作ハンドル」のようなもの
- あらゆるリソース（バッファ、テクスチャ、パイプラインなど）をこのデバイス経由で作成
- コマンド（描画や計算）をまとめて送るための出発点

### **どうやってデバイスを手に入れるの？**

以下のようなステップで取得します：

```ts
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()
```

1. `requestAdapter()`

   - お使いの環境に適したGPUアダプターを取得（ざっくり言うと「GPUを使えるか確認」）

2. `requestDevice()`
   - アダプターから「デバイス」を要求する（GPUとのやりとりを開始）

### **デバイスで何ができるの？**

`device`を使って以下のようなことができます：

- バッファ（GPUに送るデータ）を作る  
  → `device.createBuffer(...)`

- シェーダーをコンパイルする  
  → `device.createShaderModule(...)`

- 描画や計算のパイプラインを構築する  
  → `device.createRenderPipeline(...)`

- コマンドをまとめるエンコーダーを作る  
  → `device.createCommandEncoder()`

- キューに送信してGPUに実行してもらう  
  → `device.queue.submit([...])`

---

## [DRAFT]

- **Adapter（アダプタ）**：物理GPUへの橋渡し
- **Logical Device（論理デバイス）**：Webアプリごとの仮想GPUインターフェース

### なぜ論理的と物理的に分かれているの？

これは**抽象化と安全性のため**です。

- 物理GPU（アダプタ）はOSやドライバが管理していて、直接触るのは危険
- デバイス（論理GPU）を通すことで、**安全・効率的にGPU操作ができる**
- ひとつのGPUに対して、**複数のアプリが同時にデバイスを作って使える**

| 用語     | 簡単な定義                      | 実例・使いどころ               |
| -------- | ------------------------------- | ------------------------------ |
| アダプタ | PCにある物理GPU（どれを使う？） | どのGPUを使うか選ぶ、性能確認  |
| デバイス | 選んだGPUを使うためのハンドル   | リソースを作る、描画命令を出す |

「このGPUを使いたいです！」 → アダプタ  
「わかりました、このデバイスで操作してください」 → デバイス

### アダプタの次にやること

アダプタを取得したら、次に「**デバイス（GPUの実行ユニット）**」を作成します：

```js
const device = await adapter.requestDevice()
```

ここでやっと、実際にGPUに命令を出せるようになります。

## デバイス（Device）

デバイスは「レストランの厨房への注文窓口」のようなものです。

- 客（あなたのプログラム）がやりたいこと（描画や計算）を伝える
- 窓口（デバイス）を通して、厨房（GPU）に材料（バッファ）やレシピ（シェーダー）を渡す
- 最後に「注文して！」とまとめて伝える（コマンドを送る）

## WebGLとの比較：初期化処理の非同期化

---

| 要素                | 概要                                                 |
| ------------------- | ---------------------------------------------------- |
| `GPUAdapter`        | 利用可能なGPUの情報を取得するためのインタフェース    |
| `GPUDevice`         | GPUとの実際の通信・処理を担当するオブジェクト        |
| `GPUBuffer`         | 頂点情報や演算対象のデータなど、GPU上で使うバッファ  |
| `GPUTexture`        | テクスチャやフレームバッファなど画像データ用リソース |
| `GPUPipeline`       | シェーダーやレンダリングの設定をまとめたオブジェクト |
| `GPUCommandEncoder` | 描画や計算処理の命令を記録するための仕組み           |
| `GPUQueue`          | エンコードされた命令をGPUに送信するキュー            |
