---
title: 歴史から見るWebGPUのコンセプト
date: "2025-04-09"
description: WebGPUはWebGLのどんな側面を解決するのか
series: webgpu-concept
tags:
  - webgpu
  - webgl
---

## なぜ「WebGLの後継」が必要なのか

### GPUは進化している

従来、GPUハードウェアの持つグラフィックス演算機能をソフトウェアから呼び出すには、==OpenGL（Open Graphics Library）==というAPIが広く利用されてきました。
そして、Webブラウザ上でGPUを使った描画を実現する手段として、OpenGLをベースに設計された==WebGL==が登場しました。

しかし、OpenGLは1990年代に設計されたAPIであり、現代のGPUやCPUが持つ高度な処理能力を効率よく活かすには限界があります。

その結果、AppleやMicrosoftは、OSのアーキテクチャと親和性の高い新たなグラフィックスAPIを開発し、それぞれ==Metal==と==Direct X==として、人気を集め始めています。
OpenGLの開発を主導していたKhronos Groupも、後継APIとして==Vulkan==を開発しており、現在OpenGL自体の更新はほぼ停止しているのが実情です。

このように、WebGLがベースとしているOpenGL APIが時代遅れとなった以上、WebGL自体も刷新が求められるようになりました。
最新のGPU機能をブラウザ上でも活用するには、**WebGLの枠を超えた新しい仕組み**が必要です。

### GPUの用途は広がっている

本来GPUは、グラフィックス描画を高速化するために開発されましたが、近年では==機械学習==や==シミュレーション==といった、非グラフィックス用途での活用も急速に進んでいます。
膨大なデータを取り扱うこのような用途では、データを並列で処理できるGPUのメリットを大いに活用できるからです。

このように、汎用的な計算処理にGPUを利用する技術は、==GPGPU（General-Purpose computing on GPU）==と呼ばれます。

しかし、WebGLはこのような汎用的な用途を想定して設計されていないため、ブラウザでGPGPUを実現するには多くの制約がありました。

## WebGLによるGPGPUの限界

### WebGL 1.0の限界

WebGL 1.0では、==シェーダ==（GPUで動作するプログラム）で任意のデータを処理すること自体が面倒で、GPGPUの夢は遠いものでした。
WebGL 1.0でGPGPUを実現するには、次のような壁を乗り越える必要があります。

- ユニフォームとしてシェーダに送ることができるデータ容量が少ない
- 大量のデータを処理したい場合は、テクスチャに書き込んで渡す必要がある（このとき、高い精度が求められる場合は、==浮動小数点数テクスチャ==を使う必要がある）
- 頂点シェーダーでテクスチャから値を読み出すには、==VTF（Vertex Texture Fetch）==が使えるGPUでなければならない
- シェーダーの出力は基本的にピクセル（ラスタライズされたグラフィックス）であり、そこからデータを取り出す手間がかかる

これらの技術的詳細については、[wgld.org](https://wgld.org/)の以下の記事で詳しく解説されています：

- [浮動小数点数テクスチャ](https://wgld.org/d/webgl/w070.html)
- [頂点テクスチャフェッチ(VTF)](https://wgld.org/d/webgl/w071.html)
- [浮動小数点数VTF](https://wgld.org/d/webgl/w072.html)
- [GPGPUでパーティクルを大量に描く](https://wgld.org/d/webgl/w083.html)

### WebGL 2.0でも残る制約

WebGL 2.0では、==Transform Feedback==と呼ばれる機能により、GPGPUがある程度容易になりました。

Transform Feedbackを使うと、シェーダの出力をグラフィックスとして描画するのではなく、直接==バッファ==へ書き戻すことが可能になります。
これは、データをテクスチャ化し、演算結果もGPUで描画されたテクスチャから取り出すという、「描画結果をグラフィックスとして扱う」手法から、「計算結果をデータとしてGPUから取り出す」手法へと一歩進んだものです。

こちらに関しても、詳細は[wgld.org](https://wgld.org/)の次の記事で解説されています：

- [Transform Feedbackの基礎](https://wgld.org/d/webgl2/w014.html)
- [Transform FeedbackでGPGPU](https://wgld.org/d/webgl2/w015.html)

ただし、Transform Feedbackでも演算を行うのは依然として==頂点シェーダー==です。
これはグラフィックス向けに設計されたものであり、汎用計算に適した柔軟な最適化は難しいのが現状です。

本格的なGPGPUを行うには、DirectXやMetalなどが提供する==コンピュートシェーダ==（汎用計算専用のGPUプログラム）のような仕組みが必要になります。

## WebGPUの登場

このような背景から、次世代のGPU APIとして登場したのが==WebGPU==です。
Vulkan、Metal、DirectX 12といった現代的なネイティブAPIの設計思想や機能をベースに、Web向けに最適化されたAPIです。

WebGLがOpenGLを薄くラップしたものだったのに対し、WebGPUはそうしたネイティブAPIを単純に模倣するのではなく、**独自の抽象化**を導入しています。

わざわざ独自の設計を策定しているのは、**WebらしいAPI**にするためともいえます。
たとえば、手動のメモリ管理など、各プラットフォームのネイティブAPIに含まれる低レベルの概念の多くは、Webには不向きなものだからです。

WebGPUは「Webらしさ」を保ちながら、どのプラットフォームのGPUでも一貫して動作できるよう設計されています。Vulkan・Metal・DirectXの間にある設計の違いをうまく抽象化しており、開発者にとって一貫性のあるAPIを提供します。

そして、WebGPUでは、==コンピュートシェーダ==が正式にサポートされました。
これにより、グラフィックスに依存しない形で、たとえば次のような純粋なデータ処理をGPU上で高速に実行できます。

- 機械学習の推論処理
- 粒子シミュレーション
- 物理エンジンの一部
- 並列行列演算
- etc.

現在、WebGPUはW3Cで標準化が進められており、Google、Apple、Microsoft、Mozillaなど、主要ブラウザベンダーがその策定に参加しています。
