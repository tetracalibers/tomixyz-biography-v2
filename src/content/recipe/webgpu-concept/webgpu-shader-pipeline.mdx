---
title: WebGPUのシェーダとパイプライン
date: "2025-04-19"
description: シェーダを使って三角形を描画する
series: webgpu-concept
references:
  - title: WebGPU入門 - WebGPUで三角形を表示する
    url: https://zenn.dev/emadurandal/books/cb6818fd3a1b2e/viewer/hello_triangle
  - title: WebGPU Fundamentals
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html
  - title: WebGPU WGSL
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl.html
tags:
  - webgpu
draft: true
---

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGpuTriangleNoBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle-no-buffer.png"

キャンバスの初期化ができたら、今度はその上に何らかの図形を表示したくなるでしょう。
今回からは、WebGPUで三角形を描くことを目指して、まだ解説していないWebGPUの構成要素について触れていきます。

## 描画コマンドからすべてが始まる

三角形の描画を行うにはさまざまな準備が必要ですが、わかりやすいように、まずは描画コマンドから見ていくことにします。必要なものは後から用意していくことにしましょう。

描画に関係する命令は、`beginRenderPass(){:js}`メソッドの呼び出しで得られる、描画専用のコマンドエンコーダ`renderPass{:js}`（`GPURenderPassEncoder{:js}`オブジェクト）に対して呼び出すことができます。

```js {2-3}
const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
// ここはbeginRenderPass()とend()の間
// ここで描画命令を登録していく
renderPass.end()
```

「図形を描画せよ」という命令を登録するのが、`renderPass{:js}`が持つ`draw(){:js}`メソッドです。

`draw(){:js}`メソッドの第1引数には、描画する図形の頂点数を指定します。
三角形は3つの頂点から成る図形なので、`draw(3){:js}`と呼び出せばよいわけです。

```js {2}
const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
renderPass.draw(3)
renderPass.end()
```

`draw(){:js}`メソッドによって、キャンバス上での頂点の座標を計算する処理が、各頂点に対して呼び出されるように設定されます。
`draw(3){:js}`と呼び出した場合は、「頂点の座標を計算する処理」が3回呼び出されることになります。

## GPUでの描画にはシェーダが必要

WebGPUでは、GPUを使って描画処理を行います。
基本的に、GPU上で行われる処理はWebGPUによって隠蔽されていますが、==シェーダ==(Shader)と呼ばれるプログラムを作成することで、GPUでの処理の一部を私たちが実装できるようになっています。

シェーダは、==WGSL==（WebGPU Shading Language）という専用の言語で記述します。

描画処理を行う場合、用意するシェーダは、==頂点シェーダ==(Vertex Shader)と==フラグメントシェーダ==(Fragment Shader)の2種類です。

## 頂点シェーダの実装

「頂点の座標を計算する処理」を担うのが、頂点シェーダです。
つまり、`renderPass.draw(3){:js}`という描画コマンドを呼び出した場合は、頂点シェーダが3回呼び出されることになるのです。

頂点シェーダは、頂点の座標を返す関数として定義します。

```wgsl showLineNumbers
struct VertexInput {
  @builtin(vertex_index) VertexIndex: u32
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}
```

---

## [DRAFT]

GPUは各三角形が画面上のどのピクセルをカバーするかを計算します（==ラスタライズ==）。

その後、各ピクセルは==フラグメントシェーダ==によって処理されます。
フラグメントシェーダはピクセル座標だけでなく、そのピクセルの色を決定するための補助データにもアクセスできます。

データを頂点シェーダに渡し、次にフラグメント シェーダに渡して画面に直接出力するこのシステムはパイプラインと呼ばれ、WebGPU ではパイプラインを明示的に定義する必要があります。

## 実装：キャンバスに三角形を描画する

<DemoLinkWithResult
  url="/demo/webgpu-triangle-no-buffer"
  result={img_WebGpuTriangleNoBuffer}
  title="WebGPUで三角形を描画するデモ"
/>

```wgsl title="シェーダのコード" showLineNumbers
struct VertexInput {
  @builtin(vertex_index) VertexIndex: u32
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```ts title="JavaScriptのコード" showLineNumbers {10-12,14-26,41-42}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const shaderModule = device.createShaderModule({
  code: `シェーダのコードをここに埋め込み`
})

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  },
  primitive: { topology: "triangle-list" }
})

const commandEncoder = device.createCommandEncoder()
const renderPassDescriptor = {
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.32, g: 0.34, b: 0.36, a: 1 },
      storeOp: "store"
    }
  ]
}

const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
renderPass.setPipeline(renderPipeline)
renderPass.draw(3)
renderPass.end()

device.queue.submit([encoder.finish()])
```
