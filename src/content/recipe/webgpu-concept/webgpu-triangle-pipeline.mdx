---
title: シェーダを動かすパイプライン
date: "2025-04-20"
description: レンダーパイプラインで三角形を表示する
series: webgpu-concept
references:
  - title: WebGPU入門 - WebGPUで三角形を表示する
    url: https://zenn.dev/emadurandal/books/cb6818fd3a1b2e/viewer/hello_triangle
  - title: WebGPU Fundamentals
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html
tags:
  - webgpu
draft: true
---

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGpuTriangleNoBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle-no-buffer.png"

:SeriesPrevLink[前回]{series="webgpu-concept" current="webgpu-triangle-pipeline"}は、三角形の描画に必要なシェーダを実装しました。

今回は、そのシェーダを使って、実際に三角形を表示するためのWebGPUのコードを実装します。

## シェーダをWebGPUに渡す

シェーダを動かすには、シェーダのコード（WGSLコード）をGPUが理解できる形式に変換してから、GPUに渡す必要があります。
WGSLコードをGPUが理解できる形式に変換する作業を==コンパイル==といいます。

WGSLコードのコンパイルは、WebGPU内部で行ってくれますが、そのためにはWGSLコードを=p=WebGPUに登録==する必要があります。

### シェーダモジュールの作成

WGSLコードをJavaScriptからWebGPUに渡すときに使うのが、`device.createShaderModule{:js}`メソッドです。

このメソッドにWGSLコードを文字列として渡すことで、==シェーダモジュール==（`GPUShaderModule{:ts}`）というオブジェクトが作られます。
単なる文字列だったWGSLコードを、描画処理を構成する1つの部品（モジュール）としてWebGPUが使えるようにしたものが、==シェーダモジュール==です。

実際に、前回実装したWGSLコードを文字列として渡して、シェーダモジュールを作成するコードは次のようになります。

```ts showLineNumbers title="シェーダモジュールを作成する"
const shaderModule = device.createShaderModule({
  code: `
    struct VertexInput {
      @builtin(vertex_index) VertexIndex: u32
    };

    struct VertexOutput {
      @builtin(position) Position: vec4f
    };

    @vertex
    fn vs_main(in: VertexInput) -> VertexOutput {
      var pos = array<vec2f, 3>(
        vec2f( 0.0,  0.5),
        vec2f(-0.5, -0.5),
        vec2f( 0.5, -0.5)
      );
    
      var out: VertexOutput;
      out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
      return out;
    }

    @fragment
    fn fs_main() -> @location(0) vec4f {
      return vec4f(0.918, 0.561, 0.918, 1.0);
    }`
})
```

### 補足：Viteなどのビルドツールを使う

先ほど示したような、シェーダのコードをJavaScriptの文字列として埋め込む方法では、エディタのシンタックスハイライト機能の恩恵を受けられないですし、JavaScriptのコード全体が読みづらくなります。

シェーダのコードを別ファイルに分けて書きたい場合は、[Vite](https://ja.vite.dev/)などのビルドツールを使うと便利です。

たとえば、Viteでビルドする場合は、`shader.wgsl`という別ファイルに書いたシェーダのコードを、次のように`.js`（`.ts`）ファイルで`import{:js}`して使うことができます。

```ts title="Viteでビルドする場合の例"
// ?rawをつけることで、シェーダのコードを文字列としてimportできる
import shaderCode from "./shader.wgsl?raw"

const shaderModule = device.createShaderModule({
  code: shaderCode
})
```

### 発展：コンパイルエラーの検出

> [!caution]
> TODO

- コンパイルの結果は `compilationInfo()` で確認できる

```ts
// エラーチェック（非同期でバリデーション情報を取得）
shaderModule.compilationInfo().then((info) => {
  if (info.messages.length > 0) {
    for (const msg of info.messages) {
      console.warn(`${msg.lineNum}:${msg.linePos} - ${msg.message}`)
    }
    if (info.messages.some((m) => m.type === "error")) {
      throw new Error("シェーダのコンパイルに失敗しました")
    }
  }
})
```

## シェーダの使い方を伝える仕組み

シェーダを意図通りGPUに使ってもらうためには、GPUに対してさまざまな補足説明を伝える必要があります。

### レンダーパイプライン

WebGPUでは、==レンダーパイプライン==（`GPURenderPipeline{:ts}`）というオブジェクトに、シェーダの実行に関する設定を詰め込みます。

- シェーダーの設定：どのシェーダーを使うか
- 入力レイアウト：頂点データの構成はどうなっているか
- レンダーターゲットの設定：色をどう合成するか（ブレンド）etc.
- プリミティブの設定：どのように頂点を結ぶか
- 深度ステンシルの設定
- マルチサンプリングの設定

言うなれば、レンダーパイプラインは=p=シェーダの調理法を詰め込んだレシピ==です。

### 補足：パイプラインという名前の解釈

グラフィックスAPIにおいて、==パイプライン==は「処理の流れ」のような意味を持つ言葉です。
たとえば、GPUのパイプラインは「頂点シェーダ→ラスタライズ→フラグメントシェーダ」という流れで処理を行います。

WebGPUにおける`GPURenderPipeline{:ts}`オブジェクトは、パイプラインの各処理工程に対して、それぞれ「どんな設定に基づいて処理してほしいか」をまとめて定義したものといえます。

その処理工程ではどういう「状態｣であってほしいか、WebGLではグローバルに散らばっていた状態を、WebGPUではレンダーパイプラインというオブジェクトに閉じ込めてしまうのです。設定をオブジェクト化することにより、その設定を使い回すことも容易になります。

## レンダーパイプラインを作成する

> [!caution]
> TODO

レンダーパイプラインは、`device.createRenderPipeline(){:js}`メソッドで作成します。

このメソッドの引数には、さまざまな設定をオブジェクトに詰め込んで渡します。とはいえ、三角形を描くだけなら、あまり多くの設定は必要ありません。

```ts showLineNumbers title="レンダーパイプラインを作成する"
const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})
```

### 頂点シェーダの設定

```ts showLineNumbers {3-6}
const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})
```

### フラグメントシェーダの設定

```ts showLineNumbers {7-9,11}
const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})
```

### レンダーターゲットの設定

```ts showLineNumbers {10}
const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})
```

- フラグメントシェーダ出力の`@location(0)`の意味

### レイアウト

```ts showLineNumbers {2}
const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})
```

## レンダーパイプラインを使う

> [!caution]
> TODO

生成したパイプラインは、コマンドエンコーダーの中でこう使います：

```ts showLineNumbers title="レンダーパイプラインを使うように設定" {2}
const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
renderPass.setPipeline(pipeline)
renderPass.draw(3)
renderPass.end()
```

これによって、GPUは「どう描画すべきか」のルールに従って描画を実行します。

## 実装：キャンバスに三角形を描画する

> [!caution]
> TODO

<DemoLinkWithResult
  url="/demo/webgpu-triangle-no-buffer"
  result={img_WebGpuTriangleNoBuffer}
  title="WebGPUで三角形を描画するデモ"
/>

```wgsl title="WGSLのコード（シェーダ）" showLineNumbers
struct VertexInput {
  @builtin(vertex_index) VertexIndex: u32
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```ts title="JavaScriptのコード" showLineNumbers {10-12,14-25,40-41}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const shaderModule = device.createShaderModule({
  code: `(WGSL code)`
})

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  }
})

const commandEncoder = device.createCommandEncoder()
const renderPassDescriptor = {
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.32, g: 0.34, b: 0.36, a: 1 },
      storeOp: "store"
    }
  ]
}

const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
renderPass.setPipeline(renderPipeline)
renderPass.draw(3)
renderPass.end()

device.queue.submit([encoder.finish()])
```
