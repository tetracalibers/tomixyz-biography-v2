---
title: シェーダを動かすパイプライン
date: "2025-04-20"
description: レンダーパイプラインで三角形を表示する
series: webgpu-concept
references:
  - title: WebGPU入門 - WebGPUで三角形を表示する
    url: https://zenn.dev/emadurandal/books/cb6818fd3a1b2e/viewer/hello_triangle
  - title: WebGPU Fundamentals
    url: https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html
tags:
  - webgpu
draft: true
---

import DemoLinkWithResult from "$/components/demo/DemoLinkWithResult.astro"

import img_WebGpuTriangleNoBuffer from "../../../assets/recipes/webgpu-concept/webgpu-triangle-no-buffer.png"

> [!note]
> ここで学ぶこと
>
> - レンダーパイプライン
> - フラグメントシェーダ出力の`@location(0)`の意味

## [DRAFT]

データを頂点シェーダに渡し、次にフラグメント シェーダに渡して画面に直接出力するこのシステムはパイプラインと呼ばれ、WebGPU ではパイプラインを明示的に定義する必要があります。

## 実装：キャンバスに三角形を描画する

<DemoLinkWithResult
  url="/demo/webgpu-triangle-no-buffer"
  result={img_WebGpuTriangleNoBuffer}
  title="WebGPUで三角形を描画するデモ"
/>

```wgsl title="シェーダのコード" showLineNumbers
struct VertexInput {
  @builtin(vertex_index) VertexIndex: u32
};

struct VertexOutput {
  @builtin(position) Position: vec4f
};

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
  var pos = array<vec2f, 3>(
    vec2f( 0.0,  0.5),
    vec2f(-0.5, -0.5),
    vec2f( 0.5, -0.5)
  );

  var out: VertexOutput;
  out.Position = vec4f(pos[in.VertexIndex], 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4f {
  return vec4f(0.918, 0.561, 0.918, 1.0);
}
```

```ts title="JavaScriptのコード" showLineNumbers {10-12,14-26,41-42}
const adapter = await navigator.gpu.requestAdapter()
const device = await adapter.requestDevice()

const canvas = document.querySelector("canvas")
const context = canvas.getContext("webgpu")

const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({ device, format: canvasFormat })

const shaderModule = device.createShaderModule({
  code: `シェーダのコードをここに埋め込み`
})

const renderPipeline = device.createRenderPipeline({
  layout: "auto",
  vertex: {
    module: shaderModule,
    entryPoint: "vs_main"
  },
  fragment: {
    module: shaderModule,
    entryPoint: "fs_main",
    targets: [{ format: canvasFormat }]
  },
  primitive: { topology: "triangle-list" }
})

const commandEncoder = device.createCommandEncoder()
const renderPassDescriptor = {
  colorAttachments: [
    {
      view: context.getCurrentTexture().createView(),
      loadOp: "clear",
      clearValue: { r: 0.32, g: 0.34, b: 0.36, a: 1 },
      storeOp: "store"
    }
  ]
}

const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor)
renderPass.setPipeline(renderPipeline)
renderPass.draw(3)
renderPass.end()

device.queue.submit([encoder.finish()])
```
